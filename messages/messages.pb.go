// Code generated by protoc-gen-go.
// source: messages.proto
// DO NOT EDIT!

/*
Package messages is a generated protocol buffer package.

It is generated from these files:
	messages.proto

It has these top-level messages:
	Task
	StatusUpdate
	StatusUpdateRecord
	SubmitSchedulerRequest
	SubmitSchedulerResponse
	ExecutorToFrameworkMessage
	FrameworkToExecutorMessage
	RegisterFrameworkMessage
	ReregisterFrameworkMessage
	FrameworkRegisteredMessage
	FrameworkReregisteredMessage
	UnregisterFrameworkMessage
	DeactivateFrameworkMessage
	ResourceRequestMessage
	ResourceOffersMessage
	LaunchTasksMessage
	RescindResourceOfferMessage
	ReviveOffersMessage
	RunTaskMessage
	KillTaskMessage
	StatusUpdateMessage
	StatusUpdateAcknowledgementMessage
	LostSlaveMessage
	ReconcileTasksMessage
	FrameworkErrorMessage
	RegisterSlaveMessage
	ReregisterSlaveMessage
	SlaveRegisteredMessage
	SlaveReregisteredMessage
	UnregisterSlaveMessage
	MasterSlaveConnection
	PingSlaveMessage
	PongSlaveMessage
	ShutdownFrameworkMessage
	ShutdownExecutorMessage
	UpdateFrameworkMessage
	CheckpointResourcesMessage
	UpdateSlaveMessage
	RegisterExecutorMessage
	ExecutorRegisteredMessage
	ExecutorReregisteredMessage
	ExitedExecutorMessage
	ReconnectExecutorMessage
	ReregisterExecutorMessage
	ShutdownMessage
	Archive
	TaskHealthStatus
	HookExecuted
	FrameworkID
	OfferID
	SlaveID
	TaskID
	ExecutorID
	ContainerID
	TimeInfo
	DurationInfo
	Address
	URL
	Unavailability
	MachineID
	MachineInfo
	FrameworkInfo
	HealthCheck
	CommandInfo
	ExecutorInfo
	MasterInfo
	SlaveInfo
	Value
	Attribute
	Resource
	TrafficControlStatistics
	ResourceStatistics
	ResourceUsage
	PerfStatistics
	Request
	Offer
	InverseOffer
	TaskInfo
	TaskStatus
	Filters
	Environment
	Parameter
	Parameters
	Credential
	Credentials
	RateLimit
	RateLimits
	Image
	Volume
	NetworkInfo
	ContainerInfo
	ContainerStatus
	Labels
	Label
	Port
	Ports
	DiscoveryInfo
	AppcImageManifest
*/
package messages

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// *
// Status is used to indicate the state of the scheduler and executor
// driver after function calls.
type Status int32

const (
	Status_DRIVER_NOT_STARTED Status = 1
	Status_DRIVER_RUNNING     Status = 2
	Status_DRIVER_ABORTED     Status = 3
	Status_DRIVER_STOPPED     Status = 4
)

var Status_name = map[int32]string{
	1: "DRIVER_NOT_STARTED",
	2: "DRIVER_RUNNING",
	3: "DRIVER_ABORTED",
	4: "DRIVER_STOPPED",
}
var Status_value = map[string]int32{
	"DRIVER_NOT_STARTED": 1,
	"DRIVER_RUNNING":     2,
	"DRIVER_ABORTED":     3,
	"DRIVER_STOPPED":     4,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}
func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// *
// Describes possible task states. IMPORTANT: Mesos assumes tasks that
// enter terminal states (see below) imply the task is no longer
// running and thus clean up any thing associated with the task
// (ultimately offering any resources being consumed by that task to
// another task).
type TaskState int32

const (
	TaskState_TASK_STAGING  TaskState = 6
	TaskState_TASK_STARTING TaskState = 0
	TaskState_TASK_RUNNING  TaskState = 1
	TaskState_TASK_FINISHED TaskState = 2
	TaskState_TASK_FAILED   TaskState = 3
	TaskState_TASK_KILLED   TaskState = 4
	TaskState_TASK_LOST     TaskState = 5
	TaskState_TASK_ERROR    TaskState = 7
)

var TaskState_name = map[int32]string{
	6: "TASK_STAGING",
	0: "TASK_STARTING",
	1: "TASK_RUNNING",
	2: "TASK_FINISHED",
	3: "TASK_FAILED",
	4: "TASK_KILLED",
	5: "TASK_LOST",
	7: "TASK_ERROR",
}
var TaskState_value = map[string]int32{
	"TASK_STAGING":  6,
	"TASK_STARTING": 0,
	"TASK_RUNNING":  1,
	"TASK_FINISHED": 2,
	"TASK_FAILED":   3,
	"TASK_KILLED":   4,
	"TASK_LOST":     5,
	"TASK_ERROR":    7,
}

func (x TaskState) Enum() *TaskState {
	p := new(TaskState)
	*p = x
	return p
}
func (x TaskState) String() string {
	return proto.EnumName(TaskState_name, int32(x))
}
func (x *TaskState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TaskState_value, data, "TaskState")
	if err != nil {
		return err
	}
	*x = TaskState(value)
	return nil
}
func (TaskState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type StatusUpdateRecord_Type int32

const (
	StatusUpdateRecord_UPDATE StatusUpdateRecord_Type = 0
	StatusUpdateRecord_ACK    StatusUpdateRecord_Type = 1
)

var StatusUpdateRecord_Type_name = map[int32]string{
	0: "UPDATE",
	1: "ACK",
}
var StatusUpdateRecord_Type_value = map[string]int32{
	"UPDATE": 0,
	"ACK":    1,
}

func (x StatusUpdateRecord_Type) Enum() *StatusUpdateRecord_Type {
	p := new(StatusUpdateRecord_Type)
	*p = x
	return p
}
func (x StatusUpdateRecord_Type) String() string {
	return proto.EnumName(StatusUpdateRecord_Type_name, int32(x))
}
func (x *StatusUpdateRecord_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StatusUpdateRecord_Type_value, data, "StatusUpdateRecord_Type")
	if err != nil {
		return err
	}
	*x = StatusUpdateRecord_Type(value)
	return nil
}
func (StatusUpdateRecord_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

// Describes the several states that a machine can be in.  A `Mode`
// applies to a machine and to all associated slaves on the machine.
type MachineInfo_Mode int32

const (
	// In this mode, a machine is behaving normally;
	// offering resources, executing tasks, etc.
	MachineInfo_UP MachineInfo_Mode = 1
	// In this mode, all slaves on the machine are expected to cooperate with
	// frameworks to drain resources.  In general, draining is done ahead of
	// a pending `unavailability`.  The resources should be drained so as to
	// maximize utilization prior to the maintenance but without knowingly
	// violating the frameworks' requirements.
	MachineInfo_DRAINING MachineInfo_Mode = 2
	// In this mode, a machine is not running any tasks and will not offer
	// any of its resources.  Slaves on the machine will not be allowed to
	// register with the master.
	MachineInfo_DOWN MachineInfo_Mode = 3
)

var MachineInfo_Mode_name = map[int32]string{
	1: "UP",
	2: "DRAINING",
	3: "DOWN",
}
var MachineInfo_Mode_value = map[string]int32{
	"UP":       1,
	"DRAINING": 2,
	"DOWN":     3,
}

func (x MachineInfo_Mode) Enum() *MachineInfo_Mode {
	p := new(MachineInfo_Mode)
	*p = x
	return p
}
func (x MachineInfo_Mode) String() string {
	return proto.EnumName(MachineInfo_Mode_name, int32(x))
}
func (x *MachineInfo_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MachineInfo_Mode_value, data, "MachineInfo_Mode")
	if err != nil {
		return err
	}
	*x = MachineInfo_Mode(value)
	return nil
}
func (MachineInfo_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{60, 0} }

type FrameworkInfo_Capability_Type int32

const (
	// Receive offers with revocable resources. See 'Resource'
	// message for details.
	// TODO(vinod): This is currently a no-op.
	FrameworkInfo_Capability_REVOCABLE_RESOURCES FrameworkInfo_Capability_Type = 1
)

var FrameworkInfo_Capability_Type_name = map[int32]string{
	1: "REVOCABLE_RESOURCES",
}
var FrameworkInfo_Capability_Type_value = map[string]int32{
	"REVOCABLE_RESOURCES": 1,
}

func (x FrameworkInfo_Capability_Type) Enum() *FrameworkInfo_Capability_Type {
	p := new(FrameworkInfo_Capability_Type)
	*p = x
	return p
}
func (x FrameworkInfo_Capability_Type) String() string {
	return proto.EnumName(FrameworkInfo_Capability_Type_name, int32(x))
}
func (x *FrameworkInfo_Capability_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FrameworkInfo_Capability_Type_value, data, "FrameworkInfo_Capability_Type")
	if err != nil {
		return err
	}
	*x = FrameworkInfo_Capability_Type(value)
	return nil
}
func (FrameworkInfo_Capability_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{61, 0, 0}
}

type Value_Type int32

const (
	Value_SCALAR Value_Type = 0
	Value_RANGES Value_Type = 1
	Value_SET    Value_Type = 2
	Value_TEXT   Value_Type = 3
)

var Value_Type_name = map[int32]string{
	0: "SCALAR",
	1: "RANGES",
	2: "SET",
	3: "TEXT",
}
var Value_Type_value = map[string]int32{
	"SCALAR": 0,
	"RANGES": 1,
	"SET":    2,
	"TEXT":   3,
}

func (x Value_Type) Enum() *Value_Type {
	p := new(Value_Type)
	*p = x
	return p
}
func (x Value_Type) String() string {
	return proto.EnumName(Value_Type_name, int32(x))
}
func (x *Value_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Value_Type_value, data, "Value_Type")
	if err != nil {
		return err
	}
	*x = Value_Type(value)
	return nil
}
func (Value_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{67, 0} }

type Offer_Operation_Type int32

const (
	Offer_Operation_LAUNCH    Offer_Operation_Type = 1
	Offer_Operation_RESERVE   Offer_Operation_Type = 2
	Offer_Operation_UNRESERVE Offer_Operation_Type = 3
	Offer_Operation_CREATE    Offer_Operation_Type = 4
	Offer_Operation_DESTROY   Offer_Operation_Type = 5
)

var Offer_Operation_Type_name = map[int32]string{
	1: "LAUNCH",
	2: "RESERVE",
	3: "UNRESERVE",
	4: "CREATE",
	5: "DESTROY",
}
var Offer_Operation_Type_value = map[string]int32{
	"LAUNCH":    1,
	"RESERVE":   2,
	"UNRESERVE": 3,
	"CREATE":    4,
	"DESTROY":   5,
}

func (x Offer_Operation_Type) Enum() *Offer_Operation_Type {
	p := new(Offer_Operation_Type)
	*p = x
	return p
}
func (x Offer_Operation_Type) String() string {
	return proto.EnumName(Offer_Operation_Type_name, int32(x))
}
func (x *Offer_Operation_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Offer_Operation_Type_value, data, "Offer_Operation_Type")
	if err != nil {
		return err
	}
	*x = Offer_Operation_Type(value)
	return nil
}
func (Offer_Operation_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{75, 0, 0} }

// Describes the source of the task status update.
type TaskStatus_Source int32

const (
	TaskStatus_SOURCE_MASTER   TaskStatus_Source = 0
	TaskStatus_SOURCE_SLAVE    TaskStatus_Source = 1
	TaskStatus_SOURCE_EXECUTOR TaskStatus_Source = 2
)

var TaskStatus_Source_name = map[int32]string{
	0: "SOURCE_MASTER",
	1: "SOURCE_SLAVE",
	2: "SOURCE_EXECUTOR",
}
var TaskStatus_Source_value = map[string]int32{
	"SOURCE_MASTER":   0,
	"SOURCE_SLAVE":    1,
	"SOURCE_EXECUTOR": 2,
}

func (x TaskStatus_Source) Enum() *TaskStatus_Source {
	p := new(TaskStatus_Source)
	*p = x
	return p
}
func (x TaskStatus_Source) String() string {
	return proto.EnumName(TaskStatus_Source_name, int32(x))
}
func (x *TaskStatus_Source) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TaskStatus_Source_value, data, "TaskStatus_Source")
	if err != nil {
		return err
	}
	*x = TaskStatus_Source(value)
	return nil
}
func (TaskStatus_Source) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{78, 0} }

// Detailed reason for the task status update.
//
// TODO(bmahler): Differentiate between slave removal reasons
// (e.g. unhealthy vs. unregistered for maintenance).
type TaskStatus_Reason int32

const (
	// TODO(jieyu): The default value when a caller doesn't check for
	// presence is 0 and so ideally the 0 reason is not a valid one.
	// Since this is not used anywhere, consider removing this reason.
	TaskStatus_REASON_COMMAND_EXECUTOR_FAILED         TaskStatus_Reason = 0
	TaskStatus_REASON_CONTAINER_LAUNCH_FAILED         TaskStatus_Reason = 21
	TaskStatus_REASON_CONTAINER_LIMITATION            TaskStatus_Reason = 19
	TaskStatus_REASON_CONTAINER_LIMITATION_DISK       TaskStatus_Reason = 20
	TaskStatus_REASON_CONTAINER_LIMITATION_MEMORY     TaskStatus_Reason = 8
	TaskStatus_REASON_CONTAINER_PREEMPTED             TaskStatus_Reason = 17
	TaskStatus_REASON_CONTAINER_UPDATE_FAILED         TaskStatus_Reason = 22
	TaskStatus_REASON_EXECUTOR_REGISTRATION_TIMEOUT   TaskStatus_Reason = 23
	TaskStatus_REASON_EXECUTOR_REREGISTRATION_TIMEOUT TaskStatus_Reason = 24
	TaskStatus_REASON_EXECUTOR_TERMINATED             TaskStatus_Reason = 1
	TaskStatus_REASON_EXECUTOR_UNREGISTERED           TaskStatus_Reason = 2
	TaskStatus_REASON_FRAMEWORK_REMOVED               TaskStatus_Reason = 3
	TaskStatus_REASON_GC_ERROR                        TaskStatus_Reason = 4
	TaskStatus_REASON_INVALID_FRAMEWORKID             TaskStatus_Reason = 5
	TaskStatus_REASON_INVALID_OFFERS                  TaskStatus_Reason = 6
	TaskStatus_REASON_MASTER_DISCONNECTED             TaskStatus_Reason = 7
	TaskStatus_REASON_RECONCILIATION                  TaskStatus_Reason = 9
	TaskStatus_REASON_RESOURCES_UNKNOWN               TaskStatus_Reason = 18
	TaskStatus_REASON_SLAVE_DISCONNECTED              TaskStatus_Reason = 10
	TaskStatus_REASON_SLAVE_REMOVED                   TaskStatus_Reason = 11
	TaskStatus_REASON_SLAVE_RESTARTED                 TaskStatus_Reason = 12
	TaskStatus_REASON_SLAVE_UNKNOWN                   TaskStatus_Reason = 13
	TaskStatus_REASON_TASK_INVALID                    TaskStatus_Reason = 14
	TaskStatus_REASON_TASK_UNAUTHORIZED               TaskStatus_Reason = 15
	TaskStatus_REASON_TASK_UNKNOWN                    TaskStatus_Reason = 16
)

var TaskStatus_Reason_name = map[int32]string{
	0:  "REASON_COMMAND_EXECUTOR_FAILED",
	21: "REASON_CONTAINER_LAUNCH_FAILED",
	19: "REASON_CONTAINER_LIMITATION",
	20: "REASON_CONTAINER_LIMITATION_DISK",
	8:  "REASON_CONTAINER_LIMITATION_MEMORY",
	17: "REASON_CONTAINER_PREEMPTED",
	22: "REASON_CONTAINER_UPDATE_FAILED",
	23: "REASON_EXECUTOR_REGISTRATION_TIMEOUT",
	24: "REASON_EXECUTOR_REREGISTRATION_TIMEOUT",
	1:  "REASON_EXECUTOR_TERMINATED",
	2:  "REASON_EXECUTOR_UNREGISTERED",
	3:  "REASON_FRAMEWORK_REMOVED",
	4:  "REASON_GC_ERROR",
	5:  "REASON_INVALID_FRAMEWORKID",
	6:  "REASON_INVALID_OFFERS",
	7:  "REASON_MASTER_DISCONNECTED",
	9:  "REASON_RECONCILIATION",
	18: "REASON_RESOURCES_UNKNOWN",
	10: "REASON_SLAVE_DISCONNECTED",
	11: "REASON_SLAVE_REMOVED",
	12: "REASON_SLAVE_RESTARTED",
	13: "REASON_SLAVE_UNKNOWN",
	14: "REASON_TASK_INVALID",
	15: "REASON_TASK_UNAUTHORIZED",
	16: "REASON_TASK_UNKNOWN",
}
var TaskStatus_Reason_value = map[string]int32{
	"REASON_COMMAND_EXECUTOR_FAILED":         0,
	"REASON_CONTAINER_LAUNCH_FAILED":         21,
	"REASON_CONTAINER_LIMITATION":            19,
	"REASON_CONTAINER_LIMITATION_DISK":       20,
	"REASON_CONTAINER_LIMITATION_MEMORY":     8,
	"REASON_CONTAINER_PREEMPTED":             17,
	"REASON_CONTAINER_UPDATE_FAILED":         22,
	"REASON_EXECUTOR_REGISTRATION_TIMEOUT":   23,
	"REASON_EXECUTOR_REREGISTRATION_TIMEOUT": 24,
	"REASON_EXECUTOR_TERMINATED":             1,
	"REASON_EXECUTOR_UNREGISTERED":           2,
	"REASON_FRAMEWORK_REMOVED":               3,
	"REASON_GC_ERROR":                        4,
	"REASON_INVALID_FRAMEWORKID":             5,
	"REASON_INVALID_OFFERS":                  6,
	"REASON_MASTER_DISCONNECTED":             7,
	"REASON_RECONCILIATION":                  9,
	"REASON_RESOURCES_UNKNOWN":               18,
	"REASON_SLAVE_DISCONNECTED":              10,
	"REASON_SLAVE_REMOVED":                   11,
	"REASON_SLAVE_RESTARTED":                 12,
	"REASON_SLAVE_UNKNOWN":                   13,
	"REASON_TASK_INVALID":                    14,
	"REASON_TASK_UNAUTHORIZED":               15,
	"REASON_TASK_UNKNOWN":                    16,
}

func (x TaskStatus_Reason) Enum() *TaskStatus_Reason {
	p := new(TaskStatus_Reason)
	*p = x
	return p
}
func (x TaskStatus_Reason) String() string {
	return proto.EnumName(TaskStatus_Reason_name, int32(x))
}
func (x *TaskStatus_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TaskStatus_Reason_value, data, "TaskStatus_Reason")
	if err != nil {
		return err
	}
	*x = TaskStatus_Reason(value)
	return nil
}
func (TaskStatus_Reason) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{78, 1} }

type Image_Type int32

const (
	Image_APPC   Image_Type = 1
	Image_DOCKER Image_Type = 2
)

var Image_Type_name = map[int32]string{
	1: "APPC",
	2: "DOCKER",
}
var Image_Type_value = map[string]int32{
	"APPC":   1,
	"DOCKER": 2,
}

func (x Image_Type) Enum() *Image_Type {
	p := new(Image_Type)
	*p = x
	return p
}
func (x Image_Type) String() string {
	return proto.EnumName(Image_Type_name, int32(x))
}
func (x *Image_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Image_Type_value, data, "Image_Type")
	if err != nil {
		return err
	}
	*x = Image_Type(value)
	return nil
}
func (Image_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{87, 0} }

type Volume_Mode int32

const (
	Volume_RW Volume_Mode = 1
	Volume_RO Volume_Mode = 2
)

var Volume_Mode_name = map[int32]string{
	1: "RW",
	2: "RO",
}
var Volume_Mode_value = map[string]int32{
	"RW": 1,
	"RO": 2,
}

func (x Volume_Mode) Enum() *Volume_Mode {
	p := new(Volume_Mode)
	*p = x
	return p
}
func (x Volume_Mode) String() string {
	return proto.EnumName(Volume_Mode_name, int32(x))
}
func (x *Volume_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Volume_Mode_value, data, "Volume_Mode")
	if err != nil {
		return err
	}
	*x = Volume_Mode(value)
	return nil
}
func (Volume_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{88, 0} }

type NetworkInfo_Protocol int32

const (
	NetworkInfo_IPv4 NetworkInfo_Protocol = 1
	NetworkInfo_IPv6 NetworkInfo_Protocol = 2
)

var NetworkInfo_Protocol_name = map[int32]string{
	1: "IPv4",
	2: "IPv6",
}
var NetworkInfo_Protocol_value = map[string]int32{
	"IPv4": 1,
	"IPv6": 2,
}

func (x NetworkInfo_Protocol) Enum() *NetworkInfo_Protocol {
	p := new(NetworkInfo_Protocol)
	*p = x
	return p
}
func (x NetworkInfo_Protocol) String() string {
	return proto.EnumName(NetworkInfo_Protocol_name, int32(x))
}
func (x *NetworkInfo_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkInfo_Protocol_value, data, "NetworkInfo_Protocol")
	if err != nil {
		return err
	}
	*x = NetworkInfo_Protocol(value)
	return nil
}
func (NetworkInfo_Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{89, 0} }

// All container implementation types.
type ContainerInfo_Type int32

const (
	ContainerInfo_DOCKER ContainerInfo_Type = 1
	ContainerInfo_MESOS  ContainerInfo_Type = 2
)

var ContainerInfo_Type_name = map[int32]string{
	1: "DOCKER",
	2: "MESOS",
}
var ContainerInfo_Type_value = map[string]int32{
	"DOCKER": 1,
	"MESOS":  2,
}

func (x ContainerInfo_Type) Enum() *ContainerInfo_Type {
	p := new(ContainerInfo_Type)
	*p = x
	return p
}
func (x ContainerInfo_Type) String() string {
	return proto.EnumName(ContainerInfo_Type_name, int32(x))
}
func (x *ContainerInfo_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContainerInfo_Type_value, data, "ContainerInfo_Type")
	if err != nil {
		return err
	}
	*x = ContainerInfo_Type(value)
	return nil
}
func (ContainerInfo_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{90, 0} }

// Network options.
type ContainerInfo_DockerInfo_Network int32

const (
	ContainerInfo_DockerInfo_HOST   ContainerInfo_DockerInfo_Network = 1
	ContainerInfo_DockerInfo_BRIDGE ContainerInfo_DockerInfo_Network = 2
	ContainerInfo_DockerInfo_NONE   ContainerInfo_DockerInfo_Network = 3
)

var ContainerInfo_DockerInfo_Network_name = map[int32]string{
	1: "HOST",
	2: "BRIDGE",
	3: "NONE",
}
var ContainerInfo_DockerInfo_Network_value = map[string]int32{
	"HOST":   1,
	"BRIDGE": 2,
	"NONE":   3,
}

func (x ContainerInfo_DockerInfo_Network) Enum() *ContainerInfo_DockerInfo_Network {
	p := new(ContainerInfo_DockerInfo_Network)
	*p = x
	return p
}
func (x ContainerInfo_DockerInfo_Network) String() string {
	return proto.EnumName(ContainerInfo_DockerInfo_Network_name, int32(x))
}
func (x *ContainerInfo_DockerInfo_Network) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContainerInfo_DockerInfo_Network_value, data, "ContainerInfo_DockerInfo_Network")
	if err != nil {
		return err
	}
	*x = ContainerInfo_DockerInfo_Network(value)
	return nil
}
func (ContainerInfo_DockerInfo_Network) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{90, 0, 0}
}

type DiscoveryInfo_Visibility int32

const (
	DiscoveryInfo_FRAMEWORK DiscoveryInfo_Visibility = 0
	DiscoveryInfo_CLUSTER   DiscoveryInfo_Visibility = 1
	DiscoveryInfo_EXTERNAL  DiscoveryInfo_Visibility = 2
)

var DiscoveryInfo_Visibility_name = map[int32]string{
	0: "FRAMEWORK",
	1: "CLUSTER",
	2: "EXTERNAL",
}
var DiscoveryInfo_Visibility_value = map[string]int32{
	"FRAMEWORK": 0,
	"CLUSTER":   1,
	"EXTERNAL":  2,
}

func (x DiscoveryInfo_Visibility) Enum() *DiscoveryInfo_Visibility {
	p := new(DiscoveryInfo_Visibility)
	*p = x
	return p
}
func (x DiscoveryInfo_Visibility) String() string {
	return proto.EnumName(DiscoveryInfo_Visibility_name, int32(x))
}
func (x *DiscoveryInfo_Visibility) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DiscoveryInfo_Visibility_value, data, "DiscoveryInfo_Visibility")
	if err != nil {
		return err
	}
	*x = DiscoveryInfo_Visibility(value)
	return nil
}
func (DiscoveryInfo_Visibility) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{96, 0} }

// *
// Describes a task, similar to `TaskInfo`.
//
// `Task` is used in some of the Mesos messages found below.
// `Task` is used instead of `TaskInfo` if:
//   1) we need additional IDs, such as a specific
//      framework, executor, or agent; or
//   2) we do not need the additional data, such as the command run by the
//      task or the health checks.  These additional fields may be large and
//      unnecessary for some Mesos messages.
//
// `Task` is generally constructed from a `TaskInfo`.  See protobuf::createTask.
type Task struct {
	Name        *string       `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	TaskId      *TaskID       `protobuf:"bytes,2,req,name=task_id" json:"task_id,omitempty"`
	FrameworkId *FrameworkID  `protobuf:"bytes,3,req,name=framework_id" json:"framework_id,omitempty"`
	ExecutorId  *ExecutorID   `protobuf:"bytes,4,opt,name=executor_id" json:"executor_id,omitempty"`
	SlaveId     *SlaveID      `protobuf:"bytes,5,req,name=slave_id" json:"slave_id,omitempty"`
	State       *TaskState    `protobuf:"varint,6,req,name=state,enum=TaskState" json:"state,omitempty"`
	Resources   []*Resource   `protobuf:"bytes,7,rep,name=resources" json:"resources,omitempty"`
	Statuses    []*TaskStatus `protobuf:"bytes,8,rep,name=statuses" json:"statuses,omitempty"`
	// These fields correspond to the state and uuid of the latest
	// status update forwarded to the master.
	// NOTE: Either both the fields must be set or both must be unset.
	StatusUpdateState *TaskState `protobuf:"varint,9,opt,name=status_update_state,enum=TaskState" json:"status_update_state,omitempty"`
	StatusUpdateUuid  []byte     `protobuf:"bytes,10,opt,name=status_update_uuid" json:"status_update_uuid,omitempty"`
	Labels            *Labels    `protobuf:"bytes,11,opt,name=labels" json:"labels,omitempty"`
	// Service discovery information for the task. It is not interpreted
	// or acted upon by Mesos. It is up to a service discovery system
	// to use this information as needed and to handle tasks without
	// service discovery information.
	Discovery *DiscoveryInfo `protobuf:"bytes,12,opt,name=discovery" json:"discovery,omitempty"`
	// Container information for the task.
	Container        *ContainerInfo `protobuf:"bytes,13,opt,name=container" json:"container,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Task) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Task) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *Task) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *Task) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *Task) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *Task) GetState() TaskState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return TaskState_TASK_STAGING
}

func (m *Task) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Task) GetStatuses() []*TaskStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func (m *Task) GetStatusUpdateState() TaskState {
	if m != nil && m.StatusUpdateState != nil {
		return *m.StatusUpdateState
	}
	return TaskState_TASK_STAGING
}

func (m *Task) GetStatusUpdateUuid() []byte {
	if m != nil {
		return m.StatusUpdateUuid
	}
	return nil
}

func (m *Task) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Task) GetDiscovery() *DiscoveryInfo {
	if m != nil {
		return m.Discovery
	}
	return nil
}

func (m *Task) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

// *
// Describes a task's status.
//
// `StatusUpdate` is used in some of the Mesos messages found below.
// The master and agent use `StatusUpdate` to wrap a `TaskStatus` when
// passing it from the agent to the framework that spawned the task.
//
// See protobuf::createStatusUpdate.
type StatusUpdate struct {
	FrameworkId *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	ExecutorId  *ExecutorID  `protobuf:"bytes,2,opt,name=executor_id" json:"executor_id,omitempty"`
	SlaveId     *SlaveID     `protobuf:"bytes,3,opt,name=slave_id" json:"slave_id,omitempty"`
	// Since 0.23.0 we set 'status.uuid' in the executor
	// driver for all retryable status updates.
	Status    *TaskStatus `protobuf:"bytes,4,req,name=status" json:"status,omitempty"`
	Timestamp *float64    `protobuf:"fixed64,5,req,name=timestamp" json:"timestamp,omitempty"`
	// Since 0.26.0 this is deprecated in favor of 'status.uuid'.
	Uuid []byte `protobuf:"bytes,6,opt,name=uuid" json:"uuid,omitempty"`
	// This corresponds to the latest state of the task according to the
	// agent. Note that this state might be different than the state in
	// 'status' because status update manager queues updates. In other
	// words, 'status' corresponds to the update at top of the queue and
	// 'latest_state' corresponds to the update at bottom of the queue.
	LatestState      *TaskState `protobuf:"varint,7,opt,name=latest_state,enum=TaskState" json:"latest_state,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *StatusUpdate) Reset()                    { *m = StatusUpdate{} }
func (m *StatusUpdate) String() string            { return proto.CompactTextString(m) }
func (*StatusUpdate) ProtoMessage()               {}
func (*StatusUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StatusUpdate) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *StatusUpdate) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *StatusUpdate) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *StatusUpdate) GetStatus() *TaskStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *StatusUpdate) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *StatusUpdate) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *StatusUpdate) GetLatestState() TaskState {
	if m != nil && m.LatestState != nil {
		return *m.LatestState
	}
	return TaskState_TASK_STAGING
}

// *
// Encapsulates how we checkpoint a `StatusUpdate` to disk.
//
// See the StatusUpdateManager and slave/state.cpp.
type StatusUpdateRecord struct {
	Type *StatusUpdateRecord_Type `protobuf:"varint,1,req,name=type,enum=StatusUpdateRecord_Type" json:"type,omitempty"`
	// Required if type == UPDATE.
	Update *StatusUpdate `protobuf:"bytes,2,opt,name=update" json:"update,omitempty"`
	// Required if type == ACK.
	Uuid             []byte `protobuf:"bytes,3,opt,name=uuid" json:"uuid,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *StatusUpdateRecord) Reset()                    { *m = StatusUpdateRecord{} }
func (m *StatusUpdateRecord) String() string            { return proto.CompactTextString(m) }
func (*StatusUpdateRecord) ProtoMessage()               {}
func (*StatusUpdateRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StatusUpdateRecord) GetType() StatusUpdateRecord_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return StatusUpdateRecord_UPDATE
}

func (m *StatusUpdateRecord) GetUpdate() *StatusUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *StatusUpdateRecord) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

// TODO(josephw): Check if this can be removed.  This appears to be
// for backwards compatibility with very early versions of Mesos.
type SubmitSchedulerRequest struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SubmitSchedulerRequest) Reset()                    { *m = SubmitSchedulerRequest{} }
func (m *SubmitSchedulerRequest) String() string            { return proto.CompactTextString(m) }
func (*SubmitSchedulerRequest) ProtoMessage()               {}
func (*SubmitSchedulerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SubmitSchedulerRequest) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// TODO(josephw): Remove for the same reason as `SubmitSchedulerRequest`.
type SubmitSchedulerResponse struct {
	Okay             *bool  `protobuf:"varint,1,req,name=okay" json:"okay,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SubmitSchedulerResponse) Reset()                    { *m = SubmitSchedulerResponse{} }
func (m *SubmitSchedulerResponse) String() string            { return proto.CompactTextString(m) }
func (*SubmitSchedulerResponse) ProtoMessage()               {}
func (*SubmitSchedulerResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SubmitSchedulerResponse) GetOkay() bool {
	if m != nil && m.Okay != nil {
		return *m.Okay
	}
	return false
}

// *
// Sends a free-form message from the executor to the framework.
// Mesos forwards the message, if necessary, via the agents and the master.
//
// See scheduler::Event::Message.
type ExecutorToFrameworkMessage struct {
	SlaveId          *SlaveID     `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	FrameworkId      *FrameworkID `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	ExecutorId       *ExecutorID  `protobuf:"bytes,3,req,name=executor_id" json:"executor_id,omitempty"`
	Data             []byte       `protobuf:"bytes,4,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ExecutorToFrameworkMessage) Reset()                    { *m = ExecutorToFrameworkMessage{} }
func (m *ExecutorToFrameworkMessage) String() string            { return proto.CompactTextString(m) }
func (*ExecutorToFrameworkMessage) ProtoMessage()               {}
func (*ExecutorToFrameworkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ExecutorToFrameworkMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *ExecutorToFrameworkMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ExecutorToFrameworkMessage) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *ExecutorToFrameworkMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Sends a free-form message from the framework to the executor.
// Mesos forwards the message, if necessary, via the agents and the master.
//
// See scheduler::Call::Message.
type FrameworkToExecutorMessage struct {
	SlaveId          *SlaveID     `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	FrameworkId      *FrameworkID `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	ExecutorId       *ExecutorID  `protobuf:"bytes,3,req,name=executor_id" json:"executor_id,omitempty"`
	Data             []byte       `protobuf:"bytes,4,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *FrameworkToExecutorMessage) Reset()                    { *m = FrameworkToExecutorMessage{} }
func (m *FrameworkToExecutorMessage) String() string            { return proto.CompactTextString(m) }
func (*FrameworkToExecutorMessage) ProtoMessage()               {}
func (*FrameworkToExecutorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FrameworkToExecutorMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *FrameworkToExecutorMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *FrameworkToExecutorMessage) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *FrameworkToExecutorMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Subscribes the framework with the master to receive events.
//
// Used by the pre-Event/Call Mesos scheduler driver.
// See scheduler::Call::Subscribe.
type RegisterFrameworkMessage struct {
	Framework        *FrameworkInfo `protobuf:"bytes,1,req,name=framework" json:"framework,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *RegisterFrameworkMessage) Reset()                    { *m = RegisterFrameworkMessage{} }
func (m *RegisterFrameworkMessage) String() string            { return proto.CompactTextString(m) }
func (*RegisterFrameworkMessage) ProtoMessage()               {}
func (*RegisterFrameworkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RegisterFrameworkMessage) GetFramework() *FrameworkInfo {
	if m != nil {
		return m.Framework
	}
	return nil
}

// *
// Subscribes the framework with the master to receive events.
// This is used when the framework has previously registered and
// the master changes to a newly elected master.
//
// Used by the pre-Event/Call Mesos scheduler driver.
// See scheduler::Call::Subscribe.
type ReregisterFrameworkMessage struct {
	Framework        *FrameworkInfo `protobuf:"bytes,2,req,name=framework" json:"framework,omitempty"`
	Failover         *bool          `protobuf:"varint,3,req,name=failover" json:"failover,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ReregisterFrameworkMessage) Reset()                    { *m = ReregisterFrameworkMessage{} }
func (m *ReregisterFrameworkMessage) String() string            { return proto.CompactTextString(m) }
func (*ReregisterFrameworkMessage) ProtoMessage()               {}
func (*ReregisterFrameworkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ReregisterFrameworkMessage) GetFramework() *FrameworkInfo {
	if m != nil {
		return m.Framework
	}
	return nil
}

func (m *ReregisterFrameworkMessage) GetFailover() bool {
	if m != nil && m.Failover != nil {
		return *m.Failover
	}
	return false
}

// *
// Notifies the framework that the master has registered it.
// The `framework_id` holds a unique ID for distinguishing this framework.
//
// See scheduler::Event::Subscribed.
type FrameworkRegisteredMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	MasterInfo       *MasterInfo  `protobuf:"bytes,2,req,name=master_info" json:"master_info,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *FrameworkRegisteredMessage) Reset()                    { *m = FrameworkRegisteredMessage{} }
func (m *FrameworkRegisteredMessage) String() string            { return proto.CompactTextString(m) }
func (*FrameworkRegisteredMessage) ProtoMessage()               {}
func (*FrameworkRegisteredMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FrameworkRegisteredMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *FrameworkRegisteredMessage) GetMasterInfo() *MasterInfo {
	if m != nil {
		return m.MasterInfo
	}
	return nil
}

// *
// Notifies the framework that the master has reregistered it.
// This message is used in the same conditions as `ReregisterFrameworkMessage`.
//
// See scheduler::Event::Subscribed.
type FrameworkReregisteredMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	MasterInfo       *MasterInfo  `protobuf:"bytes,2,req,name=master_info" json:"master_info,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *FrameworkReregisteredMessage) Reset()                    { *m = FrameworkReregisteredMessage{} }
func (m *FrameworkReregisteredMessage) String() string            { return proto.CompactTextString(m) }
func (*FrameworkReregisteredMessage) ProtoMessage()               {}
func (*FrameworkReregisteredMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *FrameworkReregisteredMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *FrameworkReregisteredMessage) GetMasterInfo() *MasterInfo {
	if m != nil {
		return m.MasterInfo
	}
	return nil
}

// *
// Stops the framework and shuts down all its tasks and executors.
//
// Used by the pre-Event/Call Mesos scheduler driver.
// See scheduler::Call::Teardown.
type UnregisterFrameworkMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *UnregisterFrameworkMessage) Reset()                    { *m = UnregisterFrameworkMessage{} }
func (m *UnregisterFrameworkMessage) String() string            { return proto.CompactTextString(m) }
func (*UnregisterFrameworkMessage) ProtoMessage()               {}
func (*UnregisterFrameworkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UnregisterFrameworkMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

// *
// Aborts the scheduler driver and prevents further callbacks to the driver.
//
// Used exclusively by the pre-Event/Call Mesos scheduler driver.
type DeactivateFrameworkMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *DeactivateFrameworkMessage) Reset()                    { *m = DeactivateFrameworkMessage{} }
func (m *DeactivateFrameworkMessage) String() string            { return proto.CompactTextString(m) }
func (*DeactivateFrameworkMessage) ProtoMessage()               {}
func (*DeactivateFrameworkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DeactivateFrameworkMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

// *
// Requests specific resources from Mesos's allocator.
// If the allocator supports resource requests, any corresponding
// resources will be sent like a normal resource offer.
//
// Used by the pre-Event/Call Mesos scheduler driver.
// See scheduler::Call::Request.
type ResourceRequestMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	Requests         []*Request   `protobuf:"bytes,2,rep,name=requests" json:"requests,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ResourceRequestMessage) Reset()                    { *m = ResourceRequestMessage{} }
func (m *ResourceRequestMessage) String() string            { return proto.CompactTextString(m) }
func (*ResourceRequestMessage) ProtoMessage()               {}
func (*ResourceRequestMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ResourceRequestMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ResourceRequestMessage) GetRequests() []*Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

// *
// Sends resources offers to the scheduler.
//
// See scheduler::Event::Offers.
type ResourceOffersMessage struct {
	Offers []*Offer `protobuf:"bytes,1,rep,name=offers" json:"offers,omitempty"`
	Pids   []string `protobuf:"bytes,2,rep,name=pids" json:"pids,omitempty"`
	// The `inverse_offers` field is added here because we currently use it in
	// `master.cpp` when constructing the message to send to schedulers. We use
	// the original version of the proto API until we do a full refactor of all
	// the messages being sent.
	// It is not fully implemented in the old scheduler; only the V1 scheduler
	// currently implements inverse offers.
	InverseOffers    []*InverseOffer `protobuf:"bytes,3,rep,name=inverse_offers" json:"inverse_offers,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ResourceOffersMessage) Reset()                    { *m = ResourceOffersMessage{} }
func (m *ResourceOffersMessage) String() string            { return proto.CompactTextString(m) }
func (*ResourceOffersMessage) ProtoMessage()               {}
func (*ResourceOffersMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ResourceOffersMessage) GetOffers() []*Offer {
	if m != nil {
		return m.Offers
	}
	return nil
}

func (m *ResourceOffersMessage) GetPids() []string {
	if m != nil {
		return m.Pids
	}
	return nil
}

func (m *ResourceOffersMessage) GetInverseOffers() []*InverseOffer {
	if m != nil {
		return m.InverseOffers
	}
	return nil
}

// *
// Launches tasks using resources from the specified offers.
//
// Used by the pre-Event/Call Mesos scheduler driver.
// See scheduler::Call::Accept and scheduler::Call::Decline.
type LaunchTasksMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	Tasks            []*TaskInfo  `protobuf:"bytes,3,rep,name=tasks" json:"tasks,omitempty"`
	Filters          *Filters     `protobuf:"bytes,5,req,name=filters" json:"filters,omitempty"`
	OfferIds         []*OfferID   `protobuf:"bytes,6,rep,name=offer_ids" json:"offer_ids,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *LaunchTasksMessage) Reset()                    { *m = LaunchTasksMessage{} }
func (m *LaunchTasksMessage) String() string            { return proto.CompactTextString(m) }
func (*LaunchTasksMessage) ProtoMessage()               {}
func (*LaunchTasksMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *LaunchTasksMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *LaunchTasksMessage) GetTasks() []*TaskInfo {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *LaunchTasksMessage) GetFilters() *Filters {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *LaunchTasksMessage) GetOfferIds() []*OfferID {
	if m != nil {
		return m.OfferIds
	}
	return nil
}

// *
// Notifies the scheduler that a particular offer is not longer valid.
//
// See scheduler::Event::Rescind.
type RescindResourceOfferMessage struct {
	OfferId          *OfferID `protobuf:"bytes,1,req,name=offer_id" json:"offer_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *RescindResourceOfferMessage) Reset()                    { *m = RescindResourceOfferMessage{} }
func (m *RescindResourceOfferMessage) String() string            { return proto.CompactTextString(m) }
func (*RescindResourceOfferMessage) ProtoMessage()               {}
func (*RescindResourceOfferMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *RescindResourceOfferMessage) GetOfferId() *OfferID {
	if m != nil {
		return m.OfferId
	}
	return nil
}

// *
// Removes all filters previously set by the scheduler.
//
// Used by the pre-Event/Call Mesos scheduler driver.
// See scheduler::Call::Revive.
type ReviveOffersMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ReviveOffersMessage) Reset()                    { *m = ReviveOffersMessage{} }
func (m *ReviveOffersMessage) String() string            { return proto.CompactTextString(m) }
func (*ReviveOffersMessage) ProtoMessage()               {}
func (*ReviveOffersMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ReviveOffersMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

// *
// Depending on the `TaskInfo`, this message either notifies an existing
// executor to run the task, or starts a new executor and runs the task.
// This message is sent when scheduler::Call::Accept is sent with
// Offer::Operation::Launch.
//
// See executor::Event::Launch.
type RunTaskMessage struct {
	// TODO(karya): Remove framework_id after MESOS-2559 has shipped.
	FrameworkId *FrameworkID   `protobuf:"bytes,1,opt,name=framework_id" json:"framework_id,omitempty"`
	Framework   *FrameworkInfo `protobuf:"bytes,2,req,name=framework" json:"framework,omitempty"`
	Task        *TaskInfo      `protobuf:"bytes,4,req,name=task" json:"task,omitempty"`
	// The pid of the framework. This was moved to 'optional' in
	// 0.24.0 to support schedulers using the HTTP API. For now, we
	// continue to always set pid since it was required in 0.23.x.
	// When 'pid' is unset, or set to empty string, the agent will
	// forward executor messages through the master. For schedulers
	// still using the driver, this will remain set.
	Pid              *string `protobuf:"bytes,3,opt,name=pid" json:"pid,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RunTaskMessage) Reset()                    { *m = RunTaskMessage{} }
func (m *RunTaskMessage) String() string            { return proto.CompactTextString(m) }
func (*RunTaskMessage) ProtoMessage()               {}
func (*RunTaskMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *RunTaskMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *RunTaskMessage) GetFramework() *FrameworkInfo {
	if m != nil {
		return m.Framework
	}
	return nil
}

func (m *RunTaskMessage) GetTask() *TaskInfo {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *RunTaskMessage) GetPid() string {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return ""
}

// *
// Kills a specific task.
//
// See scheduler::Call::Kill and executor::Event::Kill.
type KillTaskMessage struct {
	// TODO(bmahler): Include the SlaveID here to improve the Master's
	// ability to respond for non-activated agents.
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	TaskId           *TaskID      `protobuf:"bytes,2,req,name=task_id" json:"task_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *KillTaskMessage) Reset()                    { *m = KillTaskMessage{} }
func (m *KillTaskMessage) String() string            { return proto.CompactTextString(m) }
func (*KillTaskMessage) ProtoMessage()               {}
func (*KillTaskMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *KillTaskMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *KillTaskMessage) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

// *
// Sends a task status update to the scheduler.
//
// See scheduler::Event::Update.
type StatusUpdateMessage struct {
	Update *StatusUpdate `protobuf:"bytes,1,req,name=update" json:"update,omitempty"`
	// If present, scheduler driver automatically sends an acknowledgement
	// to the `pid`.  This only applies to the pre-Event/Call Mesos
	// scheduler driver.
	Pid              *string `protobuf:"bytes,2,opt,name=pid" json:"pid,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StatusUpdateMessage) Reset()                    { *m = StatusUpdateMessage{} }
func (m *StatusUpdateMessage) String() string            { return proto.CompactTextString(m) }
func (*StatusUpdateMessage) ProtoMessage()               {}
func (*StatusUpdateMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *StatusUpdateMessage) GetUpdate() *StatusUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *StatusUpdateMessage) GetPid() string {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return ""
}

// *
// This message is used by the scheduler to acknowledge the receipt of a status
// update.  Mesos forwards the acknowledgement to the executor running the task.
//
// See scheduler::Call::Acknowledge and executor::Event::Acknowledged.
type StatusUpdateAcknowledgementMessage struct {
	SlaveId          *SlaveID     `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	FrameworkId      *FrameworkID `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	TaskId           *TaskID      `protobuf:"bytes,3,req,name=task_id" json:"task_id,omitempty"`
	Uuid             []byte       `protobuf:"bytes,4,req,name=uuid" json:"uuid,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *StatusUpdateAcknowledgementMessage) Reset()         { *m = StatusUpdateAcknowledgementMessage{} }
func (m *StatusUpdateAcknowledgementMessage) String() string { return proto.CompactTextString(m) }
func (*StatusUpdateAcknowledgementMessage) ProtoMessage()    {}
func (*StatusUpdateAcknowledgementMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{21}
}

func (m *StatusUpdateAcknowledgementMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *StatusUpdateAcknowledgementMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *StatusUpdateAcknowledgementMessage) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *StatusUpdateAcknowledgementMessage) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

// *
// Notifies the scheduler that the agent was lost.
//
// See scheduler::Event::Failure.
type LostSlaveMessage struct {
	SlaveId          *SlaveID `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *LostSlaveMessage) Reset()                    { *m = LostSlaveMessage{} }
func (m *LostSlaveMessage) String() string            { return proto.CompactTextString(m) }
func (*LostSlaveMessage) ProtoMessage()               {}
func (*LostSlaveMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *LostSlaveMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

// *
// Allows the scheduler to query the status for non-terminal tasks.
// This causes the master to send back the latest task status for
// each task in `statuses`, if possible. Tasks that are no longer
// known will result in a `TASK_LOST` update. If `statuses` is empty,
// then the master will send the latest status for each task
// currently known.
type ReconcileTasksMessage struct {
	FrameworkId      *FrameworkID  `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	Statuses         []*TaskStatus `protobuf:"bytes,2,rep,name=statuses" json:"statuses,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *ReconcileTasksMessage) Reset()                    { *m = ReconcileTasksMessage{} }
func (m *ReconcileTasksMessage) String() string            { return proto.CompactTextString(m) }
func (*ReconcileTasksMessage) ProtoMessage()               {}
func (*ReconcileTasksMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ReconcileTasksMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ReconcileTasksMessage) GetStatuses() []*TaskStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

// *
// Notifies the framework about errors during registration.
//
// See scheduler::Event::Error.
type FrameworkErrorMessage struct {
	Message          *string `protobuf:"bytes,2,req,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FrameworkErrorMessage) Reset()                    { *m = FrameworkErrorMessage{} }
func (m *FrameworkErrorMessage) String() string            { return proto.CompactTextString(m) }
func (*FrameworkErrorMessage) ProtoMessage()               {}
func (*FrameworkErrorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *FrameworkErrorMessage) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Registers the agent with the master.
//
// If registration fails, a `ShutdownMessage` is sent to the agent.
// Failure conditions are documented inline in Master::registerSlave.
type RegisterSlaveMessage struct {
	Slave *SlaveInfo `protobuf:"bytes,1,req,name=slave" json:"slave,omitempty"`
	// Resources that are checkpointed by the agent (e.g., persistent
	// volume or dynamic reservation). Frameworks need to release
	// checkpointed resources explicitly.
	CheckpointedResources []*Resource `protobuf:"bytes,3,rep,name=checkpointed_resources" json:"checkpointed_resources,omitempty"`
	// NOTE: This is a hack for the master to detect the agent's
	// version. If unset the agent is < 0.21.0.
	// TODO(bmahler): Do proper versioning: MESOS-986.
	Version          *string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RegisterSlaveMessage) Reset()                    { *m = RegisterSlaveMessage{} }
func (m *RegisterSlaveMessage) String() string            { return proto.CompactTextString(m) }
func (*RegisterSlaveMessage) ProtoMessage()               {}
func (*RegisterSlaveMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *RegisterSlaveMessage) GetSlave() *SlaveInfo {
	if m != nil {
		return m.Slave
	}
	return nil
}

func (m *RegisterSlaveMessage) GetCheckpointedResources() []*Resource {
	if m != nil {
		return m.CheckpointedResources
	}
	return nil
}

func (m *RegisterSlaveMessage) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

// *
// Registers the agent with the master.
// This is used when the agent has previously registered and
// the master changes to a newly elected master.
//
// If registration fails, a `ShutdownMessage` is sent to the agent.
// Failure conditions are documented inline in Master::reregisterSlave.
type ReregisterSlaveMessage struct {
	Slave *SlaveInfo `protobuf:"bytes,2,req,name=slave" json:"slave,omitempty"`
	// Resources that are checkpointed by the agent (e.g., persistent
	// volume or dynamic reservation). Frameworks need to release
	// checkpointed resources explicitly.
	CheckpointedResources []*Resource          `protobuf:"bytes,7,rep,name=checkpointed_resources" json:"checkpointed_resources,omitempty"`
	ExecutorInfos         []*ExecutorInfo      `protobuf:"bytes,4,rep,name=executor_infos" json:"executor_infos,omitempty"`
	Tasks                 []*Task              `protobuf:"bytes,3,rep,name=tasks" json:"tasks,omitempty"`
	CompletedFrameworks   []*Archive_Framework `protobuf:"bytes,5,rep,name=completed_frameworks" json:"completed_frameworks,omitempty"`
	// NOTE: This is a hack for the master to detect the agent's
	// version. If unset the agent is < 0.21.0.
	// TODO(bmahler): Do proper versioning: MESOS-986.
	Version          *string `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReregisterSlaveMessage) Reset()                    { *m = ReregisterSlaveMessage{} }
func (m *ReregisterSlaveMessage) String() string            { return proto.CompactTextString(m) }
func (*ReregisterSlaveMessage) ProtoMessage()               {}
func (*ReregisterSlaveMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ReregisterSlaveMessage) GetSlave() *SlaveInfo {
	if m != nil {
		return m.Slave
	}
	return nil
}

func (m *ReregisterSlaveMessage) GetCheckpointedResources() []*Resource {
	if m != nil {
		return m.CheckpointedResources
	}
	return nil
}

func (m *ReregisterSlaveMessage) GetExecutorInfos() []*ExecutorInfo {
	if m != nil {
		return m.ExecutorInfos
	}
	return nil
}

func (m *ReregisterSlaveMessage) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *ReregisterSlaveMessage) GetCompletedFrameworks() []*Archive_Framework {
	if m != nil {
		return m.CompletedFrameworks
	}
	return nil
}

func (m *ReregisterSlaveMessage) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

// *
// Notifies the agent that the master has registered it.
// The `slave_id` holds a unique ID for distinguishing this agent.
type SlaveRegisteredMessage struct {
	SlaveId          *SlaveID               `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	Connection       *MasterSlaveConnection `protobuf:"bytes,2,opt,name=connection" json:"connection,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *SlaveRegisteredMessage) Reset()                    { *m = SlaveRegisteredMessage{} }
func (m *SlaveRegisteredMessage) String() string            { return proto.CompactTextString(m) }
func (*SlaveRegisteredMessage) ProtoMessage()               {}
func (*SlaveRegisteredMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *SlaveRegisteredMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *SlaveRegisteredMessage) GetConnection() *MasterSlaveConnection {
	if m != nil {
		return m.Connection
	}
	return nil
}

// *
// Notifies the agent that the master has reregistered it.
// This message is used in the same conditions as `ReregisterSlaveMessage`.
type SlaveReregisteredMessage struct {
	SlaveId *SlaveID `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	// Contains a list of non-terminal tasks that the master believes to
	// be running on the agent.  The agent should respond `TASK_LOST` to
	// any tasks that are unknown, so the master knows to remove those.
	Reconciliations  []*ReconcileTasksMessage `protobuf:"bytes,2,rep,name=reconciliations" json:"reconciliations,omitempty"`
	Connection       *MasterSlaveConnection   `protobuf:"bytes,3,opt,name=connection" json:"connection,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *SlaveReregisteredMessage) Reset()                    { *m = SlaveReregisteredMessage{} }
func (m *SlaveReregisteredMessage) String() string            { return proto.CompactTextString(m) }
func (*SlaveReregisteredMessage) ProtoMessage()               {}
func (*SlaveReregisteredMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *SlaveReregisteredMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *SlaveReregisteredMessage) GetReconciliations() []*ReconcileTasksMessage {
	if m != nil {
		return m.Reconciliations
	}
	return nil
}

func (m *SlaveReregisteredMessage) GetConnection() *MasterSlaveConnection {
	if m != nil {
		return m.Connection
	}
	return nil
}

// *
// This message is sent by the agent to the master during agent shutdown.
// The master updates its state to reflect the removed agent.
type UnregisterSlaveMessage struct {
	SlaveId          *SlaveID `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *UnregisterSlaveMessage) Reset()                    { *m = UnregisterSlaveMessage{} }
func (m *UnregisterSlaveMessage) String() string            { return proto.CompactTextString(m) }
func (*UnregisterSlaveMessage) ProtoMessage()               {}
func (*UnregisterSlaveMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *UnregisterSlaveMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

// *
// Describes the connection between the master and agent.
type MasterSlaveConnection struct {
	// Product of max_slave_ping_timeouts * slave_ping_timeout.
	// If no pings are received within the total timeout,
	// the master will remove the agent.
	TotalPingTimeoutSeconds *float64 `protobuf:"fixed64,1,opt,name=total_ping_timeout_seconds" json:"total_ping_timeout_seconds,omitempty"`
	XXX_unrecognized        []byte   `json:"-"`
}

func (m *MasterSlaveConnection) Reset()                    { *m = MasterSlaveConnection{} }
func (m *MasterSlaveConnection) String() string            { return proto.CompactTextString(m) }
func (*MasterSlaveConnection) ProtoMessage()               {}
func (*MasterSlaveConnection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *MasterSlaveConnection) GetTotalPingTimeoutSeconds() float64 {
	if m != nil && m.TotalPingTimeoutSeconds != nil {
		return *m.TotalPingTimeoutSeconds
	}
	return 0
}

// *
// This message is periodically sent by the master to the agent.
// If the agent is connected to the master, "connected" is true.
type PingSlaveMessage struct {
	Connected        *bool  `protobuf:"varint,1,req,name=connected" json:"connected,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PingSlaveMessage) Reset()                    { *m = PingSlaveMessage{} }
func (m *PingSlaveMessage) String() string            { return proto.CompactTextString(m) }
func (*PingSlaveMessage) ProtoMessage()               {}
func (*PingSlaveMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *PingSlaveMessage) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return false
}

// *
// This message is sent by the agent to the master in response to the
// `PingSlaveMessage`.
type PongSlaveMessage struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *PongSlaveMessage) Reset()                    { *m = PongSlaveMessage{} }
func (m *PongSlaveMessage) String() string            { return proto.CompactTextString(m) }
func (*PongSlaveMessage) ProtoMessage()               {}
func (*PongSlaveMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

// *
// Tells an agent to shut down all executors of the given framework.
type ShutdownFrameworkMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ShutdownFrameworkMessage) Reset()                    { *m = ShutdownFrameworkMessage{} }
func (m *ShutdownFrameworkMessage) String() string            { return proto.CompactTextString(m) }
func (*ShutdownFrameworkMessage) ProtoMessage()               {}
func (*ShutdownFrameworkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *ShutdownFrameworkMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

// *
// Tells an agent (and consequently the executor) to shutdown an executor.
type ShutdownExecutorMessage struct {
	// TODO(vinod): Make these fields required. These are made optional
	// for backwards compatibility between 0.23.0 agent and pre 0.23.0
	// executor driver.
	ExecutorId       *ExecutorID  `protobuf:"bytes,1,opt,name=executor_id" json:"executor_id,omitempty"`
	FrameworkId      *FrameworkID `protobuf:"bytes,2,opt,name=framework_id" json:"framework_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ShutdownExecutorMessage) Reset()                    { *m = ShutdownExecutorMessage{} }
func (m *ShutdownExecutorMessage) String() string            { return proto.CompactTextString(m) }
func (*ShutdownExecutorMessage) ProtoMessage()               {}
func (*ShutdownExecutorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *ShutdownExecutorMessage) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *ShutdownExecutorMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

// *
// Broadcasts updated framework information from master to all agents.
type UpdateFrameworkMessage struct {
	FrameworkId *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	// See the comment on RunTaskMessage.pid.
	Pid              *string `protobuf:"bytes,2,opt,name=pid" json:"pid,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UpdateFrameworkMessage) Reset()                    { *m = UpdateFrameworkMessage{} }
func (m *UpdateFrameworkMessage) String() string            { return proto.CompactTextString(m) }
func (*UpdateFrameworkMessage) ProtoMessage()               {}
func (*UpdateFrameworkMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *UpdateFrameworkMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *UpdateFrameworkMessage) GetPid() string {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return ""
}

// *
// This message is sent to the agent whenever there is an update of
// the resources that need to be checkpointed (e.g., persistent volume
// or dynamic reservation).
type CheckpointResourcesMessage struct {
	Resources        []*Resource `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *CheckpointResourcesMessage) Reset()                    { *m = CheckpointResourcesMessage{} }
func (m *CheckpointResourcesMessage) String() string            { return proto.CompactTextString(m) }
func (*CheckpointResourcesMessage) ProtoMessage()               {}
func (*CheckpointResourcesMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *CheckpointResourcesMessage) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// This message is sent by the agent to the master to inform the
// master about the total amount of oversubscribed (allocated and
// allocatable) resources.
type UpdateSlaveMessage struct {
	SlaveId                 *SlaveID    `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	OversubscribedResources []*Resource `protobuf:"bytes,2,rep,name=oversubscribed_resources" json:"oversubscribed_resources,omitempty"`
	XXX_unrecognized        []byte      `json:"-"`
}

func (m *UpdateSlaveMessage) Reset()                    { *m = UpdateSlaveMessage{} }
func (m *UpdateSlaveMessage) String() string            { return proto.CompactTextString(m) }
func (*UpdateSlaveMessage) ProtoMessage()               {}
func (*UpdateSlaveMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *UpdateSlaveMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *UpdateSlaveMessage) GetOversubscribedResources() []*Resource {
	if m != nil {
		return m.OversubscribedResources
	}
	return nil
}

// *
// Subscribes the executor with the agent to receive events.
//
// See executor::Call::Subscribe.
type RegisterExecutorMessage struct {
	FrameworkId      *FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	ExecutorId       *ExecutorID  `protobuf:"bytes,2,req,name=executor_id" json:"executor_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *RegisterExecutorMessage) Reset()                    { *m = RegisterExecutorMessage{} }
func (m *RegisterExecutorMessage) String() string            { return proto.CompactTextString(m) }
func (*RegisterExecutorMessage) ProtoMessage()               {}
func (*RegisterExecutorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *RegisterExecutorMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *RegisterExecutorMessage) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

// *
// Notifies the executor that the agent has registered it.
//
// See executor::Event::Subscribed.
type ExecutorRegisteredMessage struct {
	ExecutorInfo     *ExecutorInfo  `protobuf:"bytes,2,req,name=executor_info" json:"executor_info,omitempty"`
	FrameworkId      *FrameworkID   `protobuf:"bytes,3,req,name=framework_id" json:"framework_id,omitempty"`
	FrameworkInfo    *FrameworkInfo `protobuf:"bytes,4,req,name=framework_info" json:"framework_info,omitempty"`
	SlaveId          *SlaveID       `protobuf:"bytes,5,req,name=slave_id" json:"slave_id,omitempty"`
	SlaveInfo        *SlaveInfo     `protobuf:"bytes,6,req,name=slave_info" json:"slave_info,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ExecutorRegisteredMessage) Reset()                    { *m = ExecutorRegisteredMessage{} }
func (m *ExecutorRegisteredMessage) String() string            { return proto.CompactTextString(m) }
func (*ExecutorRegisteredMessage) ProtoMessage()               {}
func (*ExecutorRegisteredMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *ExecutorRegisteredMessage) GetExecutorInfo() *ExecutorInfo {
	if m != nil {
		return m.ExecutorInfo
	}
	return nil
}

func (m *ExecutorRegisteredMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ExecutorRegisteredMessage) GetFrameworkInfo() *FrameworkInfo {
	if m != nil {
		return m.FrameworkInfo
	}
	return nil
}

func (m *ExecutorRegisteredMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *ExecutorRegisteredMessage) GetSlaveInfo() *SlaveInfo {
	if m != nil {
		return m.SlaveInfo
	}
	return nil
}

// *
// Notifies the executor that the agent has reregistered it.
//
// See executor::Event::Subscribed.
type ExecutorReregisteredMessage struct {
	SlaveId          *SlaveID   `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	SlaveInfo        *SlaveInfo `protobuf:"bytes,2,req,name=slave_info" json:"slave_info,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ExecutorReregisteredMessage) Reset()                    { *m = ExecutorReregisteredMessage{} }
func (m *ExecutorReregisteredMessage) String() string            { return proto.CompactTextString(m) }
func (*ExecutorReregisteredMessage) ProtoMessage()               {}
func (*ExecutorReregisteredMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *ExecutorReregisteredMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *ExecutorReregisteredMessage) GetSlaveInfo() *SlaveInfo {
	if m != nil {
		return m.SlaveInfo
	}
	return nil
}

// *
// Notifies the scheduler about terminated executors.
//
// See scheduler::Event::Failure.
type ExitedExecutorMessage struct {
	SlaveId          *SlaveID     `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	FrameworkId      *FrameworkID `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	ExecutorId       *ExecutorID  `protobuf:"bytes,3,req,name=executor_id" json:"executor_id,omitempty"`
	Status           *int32       `protobuf:"varint,4,req,name=status" json:"status,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ExitedExecutorMessage) Reset()                    { *m = ExitedExecutorMessage{} }
func (m *ExitedExecutorMessage) String() string            { return proto.CompactTextString(m) }
func (*ExitedExecutorMessage) ProtoMessage()               {}
func (*ExitedExecutorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *ExitedExecutorMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *ExitedExecutorMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ExitedExecutorMessage) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *ExitedExecutorMessage) GetStatus() int32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

// *
// Reestablishes the connection between executor and agent after agent failover.
// This message originates from the agent.
type ReconnectExecutorMessage struct {
	SlaveId          *SlaveID `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ReconnectExecutorMessage) Reset()                    { *m = ReconnectExecutorMessage{} }
func (m *ReconnectExecutorMessage) String() string            { return proto.CompactTextString(m) }
func (*ReconnectExecutorMessage) ProtoMessage()               {}
func (*ReconnectExecutorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *ReconnectExecutorMessage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

// *
// Subscribes the executor with the agent to receive events.
// This is used after a disconnection.  The executor must include
// any unacknowledged tasks or updates.
//
// See executor::Call::Subscribe.
type ReregisterExecutorMessage struct {
	ExecutorId       *ExecutorID     `protobuf:"bytes,1,req,name=executor_id" json:"executor_id,omitempty"`
	FrameworkId      *FrameworkID    `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	Tasks            []*TaskInfo     `protobuf:"bytes,3,rep,name=tasks" json:"tasks,omitempty"`
	Updates          []*StatusUpdate `protobuf:"bytes,4,rep,name=updates" json:"updates,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ReregisterExecutorMessage) Reset()                    { *m = ReregisterExecutorMessage{} }
func (m *ReregisterExecutorMessage) String() string            { return proto.CompactTextString(m) }
func (*ReregisterExecutorMessage) ProtoMessage()               {}
func (*ReregisterExecutorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *ReregisterExecutorMessage) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *ReregisterExecutorMessage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ReregisterExecutorMessage) GetTasks() []*TaskInfo {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *ReregisterExecutorMessage) GetUpdates() []*StatusUpdate {
	if m != nil {
		return m.Updates
	}
	return nil
}

// *
// Sends a free-form message from the master to an agent.
// The agent should gracefully terminate in response, which includes
// shutting down all executors and tasks on the agent.
type ShutdownMessage struct {
	Message          *string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ShutdownMessage) Reset()                    { *m = ShutdownMessage{} }
func (m *ShutdownMessage) String() string            { return proto.CompactTextString(m) }
func (*ShutdownMessage) ProtoMessage()               {}
func (*ShutdownMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *ShutdownMessage) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Describes Completed Frameworks, etc. for archival.
type Archive struct {
	Frameworks       []*Archive_Framework `protobuf:"bytes,1,rep,name=frameworks" json:"frameworks,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Archive) Reset()                    { *m = Archive{} }
func (m *Archive) String() string            { return proto.CompactTextString(m) }
func (*Archive) ProtoMessage()               {}
func (*Archive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *Archive) GetFrameworks() []*Archive_Framework {
	if m != nil {
		return m.Frameworks
	}
	return nil
}

type Archive_Framework struct {
	FrameworkInfo    *FrameworkInfo `protobuf:"bytes,1,req,name=framework_info" json:"framework_info,omitempty"`
	Pid              *string        `protobuf:"bytes,2,opt,name=pid" json:"pid,omitempty"`
	Tasks            []*Task        `protobuf:"bytes,3,rep,name=tasks" json:"tasks,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Archive_Framework) Reset()                    { *m = Archive_Framework{} }
func (m *Archive_Framework) String() string            { return proto.CompactTextString(m) }
func (*Archive_Framework) ProtoMessage()               {}
func (*Archive_Framework) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45, 0} }

func (m *Archive_Framework) GetFrameworkInfo() *FrameworkInfo {
	if m != nil {
		return m.FrameworkInfo
	}
	return nil
}

func (m *Archive_Framework) GetPid() string {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return ""
}

func (m *Archive_Framework) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

// *
// Message describing a task's current health status, which is sent by
// the health check program to the executor.
// On each receive, if the number of consecutive failed health checks
// meets the `consecutive_failure` configuration, then `kill_task`
// flag will be set to true.
type TaskHealthStatus struct {
	TaskId  *TaskID `protobuf:"bytes,1,req,name=task_id" json:"task_id,omitempty"`
	Healthy *bool   `protobuf:"varint,2,req,name=healthy" json:"healthy,omitempty"`
	// Flag to initiate task kill.
	KillTask *bool `protobuf:"varint,3,opt,name=kill_task,def=0" json:"kill_task,omitempty"`
	// Number of consecutive failures observed by the health check program.
	// This will not be populated if task is healthy.
	ConsecutiveFailures *int32 `protobuf:"varint,4,opt,name=consecutive_failures" json:"consecutive_failures,omitempty"`
	XXX_unrecognized    []byte `json:"-"`
}

func (m *TaskHealthStatus) Reset()                    { *m = TaskHealthStatus{} }
func (m *TaskHealthStatus) String() string            { return proto.CompactTextString(m) }
func (*TaskHealthStatus) ProtoMessage()               {}
func (*TaskHealthStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

const Default_TaskHealthStatus_KillTask bool = false

func (m *TaskHealthStatus) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *TaskHealthStatus) GetHealthy() bool {
	if m != nil && m.Healthy != nil {
		return *m.Healthy
	}
	return false
}

func (m *TaskHealthStatus) GetKillTask() bool {
	if m != nil && m.KillTask != nil {
		return *m.KillTask
	}
	return Default_TaskHealthStatus_KillTask
}

func (m *TaskHealthStatus) GetConsecutiveFailures() int32 {
	if m != nil && m.ConsecutiveFailures != nil {
		return *m.ConsecutiveFailures
	}
	return 0
}

// *
// Message to signal completion of an event within a module.
type HookExecuted struct {
	Module           *string `protobuf:"bytes,1,opt,name=module" json:"module,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HookExecuted) Reset()                    { *m = HookExecuted{} }
func (m *HookExecuted) String() string            { return proto.CompactTextString(m) }
func (*HookExecuted) ProtoMessage()               {}
func (*HookExecuted) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *HookExecuted) GetModule() string {
	if m != nil && m.Module != nil {
		return *m.Module
	}
	return ""
}

// *
// A unique ID assigned to a framework. A framework can reuse this ID
// in order to do failover (see MesosSchedulerDriver).
type FrameworkID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FrameworkID) Reset()                    { *m = FrameworkID{} }
func (m *FrameworkID) String() string            { return proto.CompactTextString(m) }
func (*FrameworkID) ProtoMessage()               {}
func (*FrameworkID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *FrameworkID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A unique ID assigned to an offer.
type OfferID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OfferID) Reset()                    { *m = OfferID{} }
func (m *OfferID) String() string            { return proto.CompactTextString(m) }
func (*OfferID) ProtoMessage()               {}
func (*OfferID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *OfferID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A unique ID assigned to a slave. Currently, a slave gets a new ID
// whenever it (re)registers with Mesos. Framework writers shouldn't
// assume any binding between a slave ID and and a hostname.
type SlaveID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SlaveID) Reset()                    { *m = SlaveID{} }
func (m *SlaveID) String() string            { return proto.CompactTextString(m) }
func (*SlaveID) ProtoMessage()               {}
func (*SlaveID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *SlaveID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A framework generated ID to distinguish a task. The ID must remain
// unique while the task is active. However, a framework can reuse an
// ID _only_ if a previous task with the same ID has reached a
// terminal state (e.g., TASK_FINISHED, TASK_LOST, TASK_KILLED, etc.).
type TaskID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TaskID) Reset()                    { *m = TaskID{} }
func (m *TaskID) String() string            { return proto.CompactTextString(m) }
func (*TaskID) ProtoMessage()               {}
func (*TaskID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *TaskID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A framework generated ID to distinguish an executor. Only one
// executor with the same ID can be active on the same slave at a
// time.
type ExecutorID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExecutorID) Reset()                    { *m = ExecutorID{} }
func (m *ExecutorID) String() string            { return proto.CompactTextString(m) }
func (*ExecutorID) ProtoMessage()               {}
func (*ExecutorID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *ExecutorID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A slave generated ID to distinguish a container. The ID must be unique
// between any active or completed containers on the slave. In particular,
// containers for different runs of the same (framework, executor) pair must be
// unique.
type ContainerID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContainerID) Reset()                    { *m = ContainerID{} }
func (m *ContainerID) String() string            { return proto.CompactTextString(m) }
func (*ContainerID) ProtoMessage()               {}
func (*ContainerID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *ContainerID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Represents time since the epoch, in nanoseconds.
type TimeInfo struct {
	Nanoseconds      *int64 `protobuf:"varint,1,req,name=nanoseconds" json:"nanoseconds,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TimeInfo) Reset()                    { *m = TimeInfo{} }
func (m *TimeInfo) String() string            { return proto.CompactTextString(m) }
func (*TimeInfo) ProtoMessage()               {}
func (*TimeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *TimeInfo) GetNanoseconds() int64 {
	if m != nil && m.Nanoseconds != nil {
		return *m.Nanoseconds
	}
	return 0
}

// *
// Represents duration in nanoseconds.
type DurationInfo struct {
	Nanoseconds      *int64 `protobuf:"varint,1,req,name=nanoseconds" json:"nanoseconds,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DurationInfo) Reset()                    { *m = DurationInfo{} }
func (m *DurationInfo) String() string            { return proto.CompactTextString(m) }
func (*DurationInfo) ProtoMessage()               {}
func (*DurationInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *DurationInfo) GetNanoseconds() int64 {
	if m != nil && m.Nanoseconds != nil {
		return *m.Nanoseconds
	}
	return 0
}

// *
// A network address.
//
// TODO(bmahler): Use this more widely.
type Address struct {
	// May contain a hostname, IP address, or both.
	Hostname         *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	Ip               *string `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Port             *int32  `protobuf:"varint,3,req,name=port" json:"port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *Address) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Address) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *Address) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

// *
// Represents a URL.
type URL struct {
	Scheme           *string      `protobuf:"bytes,1,req,name=scheme" json:"scheme,omitempty"`
	Address          *Address     `protobuf:"bytes,2,req,name=address" json:"address,omitempty"`
	Path             *string      `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	Query            []*Parameter `protobuf:"bytes,4,rep,name=query" json:"query,omitempty"`
	Fragment         *string      `protobuf:"bytes,5,opt,name=fragment" json:"fragment,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *URL) Reset()                    { *m = URL{} }
func (m *URL) String() string            { return proto.CompactTextString(m) }
func (*URL) ProtoMessage()               {}
func (*URL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *URL) GetScheme() string {
	if m != nil && m.Scheme != nil {
		return *m.Scheme
	}
	return ""
}

func (m *URL) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *URL) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *URL) GetQuery() []*Parameter {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *URL) GetFragment() string {
	if m != nil && m.Fragment != nil {
		return *m.Fragment
	}
	return ""
}

// *
// Represents an interval, from a given start time over a given duration.
// This interval pertains to an unavailability event, such as maintenance,
// and is not a generic interval.
type Unavailability struct {
	Start *TimeInfo `protobuf:"bytes,1,req,name=start" json:"start,omitempty"`
	// When added to `start`, this represents the end of the interval.
	// If unspecified, the duration is assumed to be infinite.
	Duration         *DurationInfo `protobuf:"bytes,2,opt,name=duration" json:"duration,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Unavailability) Reset()                    { *m = Unavailability{} }
func (m *Unavailability) String() string            { return proto.CompactTextString(m) }
func (*Unavailability) ProtoMessage()               {}
func (*Unavailability) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *Unavailability) GetStart() *TimeInfo {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Unavailability) GetDuration() *DurationInfo {
	if m != nil {
		return m.Duration
	}
	return nil
}

// *
// Represents a single machine, which may hold one or more slaves.
//
// NOTE: In order to match a slave to a machine, both the `hostname` and
// `ip` must match the values advertised by the slave to the master.
// Hostname is not case-sensitive.
type MachineID struct {
	Hostname         *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	Ip               *string `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MachineID) Reset()                    { *m = MachineID{} }
func (m *MachineID) String() string            { return proto.CompactTextString(m) }
func (*MachineID) ProtoMessage()               {}
func (*MachineID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *MachineID) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *MachineID) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

// *
// Holds information about a single machine, its `mode`, and any other
// relevant information which may affect the behavior of the machine.
type MachineInfo struct {
	Id   *MachineID        `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Mode *MachineInfo_Mode `protobuf:"varint,2,opt,name=mode,enum=MachineInfo_Mode" json:"mode,omitempty"`
	// Signifies that the machine may be unavailable during the given interval.
	// See comments in `Unavailability` and for the `unavailability` fields
	// in `Offer` and `InverseOffer` for more information.
	Unavailability   *Unavailability `protobuf:"bytes,3,opt,name=unavailability" json:"unavailability,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *MachineInfo) Reset()                    { *m = MachineInfo{} }
func (m *MachineInfo) String() string            { return proto.CompactTextString(m) }
func (*MachineInfo) ProtoMessage()               {}
func (*MachineInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *MachineInfo) GetId() *MachineID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MachineInfo) GetMode() MachineInfo_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return MachineInfo_UP
}

func (m *MachineInfo) GetUnavailability() *Unavailability {
	if m != nil {
		return m.Unavailability
	}
	return nil
}

// *
// Describes a framework.
type FrameworkInfo struct {
	// Used to determine the Unix user that an executor or task should
	// be launched as. If the user field is set to an empty string Mesos
	// will automagically set it to the current user.
	User *string `protobuf:"bytes,1,req,name=user" json:"user,omitempty"`
	// Name of the framework that shows up in the Mesos Web UI.
	Name *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// Note that 'id' is only available after a framework has
	// registered, however, it is included here in order to facilitate
	// scheduler failover (i.e., if it is set then the
	// MesosSchedulerDriver expects the scheduler is performing
	// failover).
	Id *FrameworkID `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	// The amount of time that the master will wait for the scheduler to
	// failover before it tears down the framework by killing all its
	// tasks/executors. This should be non-zero if a framework expects
	// to reconnect after a failover and not lose its tasks/executors.
	FailoverTimeout *float64 `protobuf:"fixed64,4,opt,name=failover_timeout,def=0" json:"failover_timeout,omitempty"`
	// If set, framework pid, executor pids and status updates are
	// checkpointed to disk by the slaves. Checkpointing allows a
	// restarted slave to reconnect with old executors and recover
	// status updates, at the cost of disk I/O.
	Checkpoint *bool `protobuf:"varint,5,opt,name=checkpoint,def=0" json:"checkpoint,omitempty"`
	// Used to group frameworks for allocation decisions, depending on
	// the allocation policy being used.
	Role *string `protobuf:"bytes,6,opt,name=role,def=*" json:"role,omitempty"`
	// Used to indicate the current host from which the scheduler is
	// registered in the Mesos Web UI. If set to an empty string Mesos
	// will automagically set it to the current hostname if one is
	// available.
	Hostname *string `protobuf:"bytes,7,opt,name=hostname" json:"hostname,omitempty"`
	// This field should match the credential's principal the framework
	// uses for authentication. This field is used for framework API
	// rate limiting and dynamic reservations. It should be set even
	// if authentication is not enabled if these features are desired.
	Principal *string `protobuf:"bytes,8,opt,name=principal" json:"principal,omitempty"`
	// This field allows a framework to advertise its web UI, so that
	// the Mesos web UI can link to it. It is expected to be a full URL,
	// for example http://my-scheduler.example.com:8080/.
	WebuiUrl *string `protobuf:"bytes,9,opt,name=webui_url" json:"webui_url,omitempty"`
	// This field allows a framework to advertise its set of
	// capabilities (e.g., ability to receive offers for revocable
	// resources).
	Capabilities []*FrameworkInfo_Capability `protobuf:"bytes,10,rep,name=capabilities" json:"capabilities,omitempty"`
	// Labels are free-form key value pairs supplied by the framework
	// scheduler (e.g., to describe additional functionality offered by
	// the framework). These labels are not interpreted by Mesos itself.
	Labels           *Labels `protobuf:"bytes,11,opt,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FrameworkInfo) Reset()                    { *m = FrameworkInfo{} }
func (m *FrameworkInfo) String() string            { return proto.CompactTextString(m) }
func (*FrameworkInfo) ProtoMessage()               {}
func (*FrameworkInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

const Default_FrameworkInfo_FailoverTimeout float64 = 0
const Default_FrameworkInfo_Checkpoint bool = false
const Default_FrameworkInfo_Role string = "*"

func (m *FrameworkInfo) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *FrameworkInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FrameworkInfo) GetId() *FrameworkID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *FrameworkInfo) GetFailoverTimeout() float64 {
	if m != nil && m.FailoverTimeout != nil {
		return *m.FailoverTimeout
	}
	return Default_FrameworkInfo_FailoverTimeout
}

func (m *FrameworkInfo) GetCheckpoint() bool {
	if m != nil && m.Checkpoint != nil {
		return *m.Checkpoint
	}
	return Default_FrameworkInfo_Checkpoint
}

func (m *FrameworkInfo) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_FrameworkInfo_Role
}

func (m *FrameworkInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *FrameworkInfo) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *FrameworkInfo) GetWebuiUrl() string {
	if m != nil && m.WebuiUrl != nil {
		return *m.WebuiUrl
	}
	return ""
}

func (m *FrameworkInfo) GetCapabilities() []*FrameworkInfo_Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *FrameworkInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

type FrameworkInfo_Capability struct {
	Type             *FrameworkInfo_Capability_Type `protobuf:"varint,1,req,name=type,enum=FrameworkInfo_Capability_Type" json:"type,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *FrameworkInfo_Capability) Reset()                    { *m = FrameworkInfo_Capability{} }
func (m *FrameworkInfo_Capability) String() string            { return proto.CompactTextString(m) }
func (*FrameworkInfo_Capability) ProtoMessage()               {}
func (*FrameworkInfo_Capability) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61, 0} }

func (m *FrameworkInfo_Capability) GetType() FrameworkInfo_Capability_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return FrameworkInfo_Capability_REVOCABLE_RESOURCES
}

// *
// Describes a health check for a task or executor (or any arbitrary
// process/command). A "strategy" is picked by specifying one of the
// optional fields; currently only 'command' is supported.
// Specifying more than one strategy is an error.
type HealthCheck struct {
	// HTTP health check - not yet recommended for use, see MESOS-2533.
	Http *HealthCheck_HTTP `protobuf:"bytes,1,opt,name=http" json:"http,omitempty"`
	// Amount of time to wait until starting the health checks.
	DelaySeconds *float64 `protobuf:"fixed64,2,opt,name=delay_seconds,def=15" json:"delay_seconds,omitempty"`
	// Interval between health checks.
	IntervalSeconds *float64 `protobuf:"fixed64,3,opt,name=interval_seconds,def=10" json:"interval_seconds,omitempty"`
	// Amount of time to wait for the health check to complete.
	TimeoutSeconds *float64 `protobuf:"fixed64,4,opt,name=timeout_seconds,def=20" json:"timeout_seconds,omitempty"`
	// Number of consecutive failures until considered unhealthy.
	ConsecutiveFailures *uint32 `protobuf:"varint,5,opt,name=consecutive_failures,def=3" json:"consecutive_failures,omitempty"`
	// Amount of time to allow failed health checks since launch.
	GracePeriodSeconds *float64 `protobuf:"fixed64,6,opt,name=grace_period_seconds,def=10" json:"grace_period_seconds,omitempty"`
	// Command health check.
	Command          *CommandInfo `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *HealthCheck) Reset()                    { *m = HealthCheck{} }
func (m *HealthCheck) String() string            { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()               {}
func (*HealthCheck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

const Default_HealthCheck_DelaySeconds float64 = 15
const Default_HealthCheck_IntervalSeconds float64 = 10
const Default_HealthCheck_TimeoutSeconds float64 = 20
const Default_HealthCheck_ConsecutiveFailures uint32 = 3
const Default_HealthCheck_GracePeriodSeconds float64 = 10

func (m *HealthCheck) GetHttp() *HealthCheck_HTTP {
	if m != nil {
		return m.Http
	}
	return nil
}

func (m *HealthCheck) GetDelaySeconds() float64 {
	if m != nil && m.DelaySeconds != nil {
		return *m.DelaySeconds
	}
	return Default_HealthCheck_DelaySeconds
}

func (m *HealthCheck) GetIntervalSeconds() float64 {
	if m != nil && m.IntervalSeconds != nil {
		return *m.IntervalSeconds
	}
	return Default_HealthCheck_IntervalSeconds
}

func (m *HealthCheck) GetTimeoutSeconds() float64 {
	if m != nil && m.TimeoutSeconds != nil {
		return *m.TimeoutSeconds
	}
	return Default_HealthCheck_TimeoutSeconds
}

func (m *HealthCheck) GetConsecutiveFailures() uint32 {
	if m != nil && m.ConsecutiveFailures != nil {
		return *m.ConsecutiveFailures
	}
	return Default_HealthCheck_ConsecutiveFailures
}

func (m *HealthCheck) GetGracePeriodSeconds() float64 {
	if m != nil && m.GracePeriodSeconds != nil {
		return *m.GracePeriodSeconds
	}
	return Default_HealthCheck_GracePeriodSeconds
}

func (m *HealthCheck) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

// Describes an HTTP health check. This is not fully implemented and not
// recommended for use - see MESOS-2533.
type HealthCheck_HTTP struct {
	// Port to send the HTTP request.
	Port *uint32 `protobuf:"varint,1,req,name=port" json:"port,omitempty"`
	// HTTP request path.
	Path *string `protobuf:"bytes,2,opt,name=path,def=/" json:"path,omitempty"`
	// Expected response statuses. Not specifying any statuses implies
	// that any returned status is acceptable.
	Statuses         []uint32 `protobuf:"varint,4,rep,name=statuses" json:"statuses,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *HealthCheck_HTTP) Reset()                    { *m = HealthCheck_HTTP{} }
func (m *HealthCheck_HTTP) String() string            { return proto.CompactTextString(m) }
func (*HealthCheck_HTTP) ProtoMessage()               {}
func (*HealthCheck_HTTP) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62, 0} }

const Default_HealthCheck_HTTP_Path string = "/"

func (m *HealthCheck_HTTP) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *HealthCheck_HTTP) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return Default_HealthCheck_HTTP_Path
}

func (m *HealthCheck_HTTP) GetStatuses() []uint32 {
	if m != nil {
		return m.Statuses
	}
	return nil
}

// *
// Describes a command, executed via: '/bin/sh -c value'. Any URIs specified
// are fetched before executing the command.  If the executable field for an
// uri is set, executable file permission is set on the downloaded file.
// Otherwise, if the downloaded file has a recognized archive extension
// (currently [compressed] tar and zip) it is extracted into the executor's
// working directory. This extraction can be disabled by setting `extract` to
// false. In addition, any environment variables are set before executing
// the command (so they can be used to "parameterize" your command).
type CommandInfo struct {
	// NOTE: MesosContainerizer does currently not support this
	// attribute and tasks supplying a 'container' will fail.
	Container   *CommandInfo_ContainerInfo `protobuf:"bytes,4,opt,name=container" json:"container,omitempty"`
	Uris        []*CommandInfo_URI         `protobuf:"bytes,1,rep,name=uris" json:"uris,omitempty"`
	Environment *Environment               `protobuf:"bytes,2,opt,name=environment" json:"environment,omitempty"`
	// There are two ways to specify the command:
	// 1) If 'shell == true', the command will be launched via shell
	// 		(i.e., /bin/sh -c 'value'). The 'value' specified will be
	// 		treated as the shell command. The 'arguments' will be ignored.
	// 2) If 'shell == false', the command will be launched by passing
	// 		arguments to an executable. The 'value' specified will be
	// 		treated as the filename of the executable. The 'arguments'
	// 		will be treated as the arguments to the executable. This is
	// 		similar to how POSIX exec families launch processes (i.e.,
	// 		execlp(value, arguments(0), arguments(1), ...)).
	// NOTE: The field 'value' is changed from 'required' to 'optional'
	// in 0.20.0. It will only cause issues if a new framework is
	// connecting to an old master.
	Shell     *bool    `protobuf:"varint,6,opt,name=shell,def=1" json:"shell,omitempty"`
	Value     *string  `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	Arguments []string `protobuf:"bytes,7,rep,name=arguments" json:"arguments,omitempty"`
	// Enables executor and tasks to run as a specific user. If the user
	// field is present both in FrameworkInfo and here, the CommandInfo
	// user value takes precedence.
	User             *string `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CommandInfo) Reset()                    { *m = CommandInfo{} }
func (m *CommandInfo) String() string            { return proto.CompactTextString(m) }
func (*CommandInfo) ProtoMessage()               {}
func (*CommandInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

const Default_CommandInfo_Shell bool = true

func (m *CommandInfo) GetContainer() *CommandInfo_ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *CommandInfo) GetUris() []*CommandInfo_URI {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *CommandInfo) GetEnvironment() *Environment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *CommandInfo) GetShell() bool {
	if m != nil && m.Shell != nil {
		return *m.Shell
	}
	return Default_CommandInfo_Shell
}

func (m *CommandInfo) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *CommandInfo) GetArguments() []string {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *CommandInfo) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

type CommandInfo_URI struct {
	Value      *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	Executable *bool   `protobuf:"varint,2,opt,name=executable" json:"executable,omitempty"`
	// In case the fetched file is recognized as an archive, extract
	// its contents into the sandbox. Note that a cached archive is
	// not copied from the cache to the sandbox in case extraction
	// originates from an archive in the cache.
	Extract *bool `protobuf:"varint,3,opt,name=extract,def=1" json:"extract,omitempty"`
	// If this field is "true", the fetcher cache will be used. If not,
	// fetching bypasses the cache and downloads directly into the
	// sandbox directory, no matter whether a suitable cache file is
	// available or not. The former directs the fetcher to download to
	// the file cache, then copy from there to the sandbox. Subsequent
	// fetch attempts with the same URI will omit downloading and copy
	// from the cache as long as the file is resident there. Cache files
	// may get evicted at any time, which then leads to renewed
	// downloading. See also "docs/fetcher.md" and
	// "docs/fetcher-cache-internals.md".
	Cache            *bool  `protobuf:"varint,4,opt,name=cache" json:"cache,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommandInfo_URI) Reset()                    { *m = CommandInfo_URI{} }
func (m *CommandInfo_URI) String() string            { return proto.CompactTextString(m) }
func (*CommandInfo_URI) ProtoMessage()               {}
func (*CommandInfo_URI) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63, 0} }

const Default_CommandInfo_URI_Extract bool = true

func (m *CommandInfo_URI) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *CommandInfo_URI) GetExecutable() bool {
	if m != nil && m.Executable != nil {
		return *m.Executable
	}
	return false
}

func (m *CommandInfo_URI) GetExtract() bool {
	if m != nil && m.Extract != nil {
		return *m.Extract
	}
	return Default_CommandInfo_URI_Extract
}

func (m *CommandInfo_URI) GetCache() bool {
	if m != nil && m.Cache != nil {
		return *m.Cache
	}
	return false
}

// Describes a container.
// Not all containerizers currently implement ContainerInfo, so it
// is possible that a launched task will fail due to supplying this
// attribute.
// NOTE: The containerizer API is currently in an early beta or
// even alpha state. Some details, like the exact semantics of an
// "image" or "options" are not yet hardened.
// TODO(tillt): Describe the exact scheme and semantics of "image"
// and "options".
type CommandInfo_ContainerInfo struct {
	// URI describing the container image name.
	Image *string `protobuf:"bytes,1,req,name=image" json:"image,omitempty"`
	// Describes additional options passed to the containerizer.
	Options          []string `protobuf:"bytes,2,rep,name=options" json:"options,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CommandInfo_ContainerInfo) Reset()                    { *m = CommandInfo_ContainerInfo{} }
func (m *CommandInfo_ContainerInfo) String() string            { return proto.CompactTextString(m) }
func (*CommandInfo_ContainerInfo) ProtoMessage()               {}
func (*CommandInfo_ContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63, 1} }

func (m *CommandInfo_ContainerInfo) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *CommandInfo_ContainerInfo) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

// *
// Describes information about an executor. The 'data' field can be
// used to pass arbitrary bytes to an executor.
type ExecutorInfo struct {
	ExecutorId  *ExecutorID  `protobuf:"bytes,1,req,name=executor_id" json:"executor_id,omitempty"`
	FrameworkId *FrameworkID `protobuf:"bytes,8,opt,name=framework_id" json:"framework_id,omitempty"`
	Command     *CommandInfo `protobuf:"bytes,7,req,name=command" json:"command,omitempty"`
	// Executor provided with a container will launch the container
	// with the executor's CommandInfo and we expect the container to
	// act as a Mesos executor.
	Container *ContainerInfo `protobuf:"bytes,11,opt,name=container" json:"container,omitempty"`
	Resources []*Resource    `protobuf:"bytes,5,rep,name=resources" json:"resources,omitempty"`
	Name      *string        `protobuf:"bytes,9,opt,name=name" json:"name,omitempty"`
	// Source is an identifier style string used by frameworks to track
	// the source of an executor. This is useful when it's possible for
	// different executor ids to be related semantically.
	// NOTE: Source is exposed alongside the resource usage of the
	// executor via JSON on the slave. This allows users to import
	// usage information into a time series database for monitoring.
	Source *string `protobuf:"bytes,10,opt,name=source" json:"source,omitempty"`
	Data   []byte  `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	// Service discovery information for the executor. It is not
	// interpreted or acted upon by Mesos. It is up to a service
	// discovery system to use this information as needed and to handle
	// executors without service discovery information.
	Discovery        *DiscoveryInfo `protobuf:"bytes,12,opt,name=discovery" json:"discovery,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ExecutorInfo) Reset()                    { *m = ExecutorInfo{} }
func (m *ExecutorInfo) String() string            { return proto.CompactTextString(m) }
func (*ExecutorInfo) ProtoMessage()               {}
func (*ExecutorInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *ExecutorInfo) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *ExecutorInfo) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ExecutorInfo) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ExecutorInfo) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ExecutorInfo) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ExecutorInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExecutorInfo) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *ExecutorInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ExecutorInfo) GetDiscovery() *DiscoveryInfo {
	if m != nil {
		return m.Discovery
	}
	return nil
}

// *
// Describes a master. This will probably have more fields in the
// future which might be used, for example, to link a framework webui
// to a master webui.
type MasterInfo struct {
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// The IP address (only IPv4) as a packed 4-bytes integer,
	// stored in network order.  Deprecated, use `address.ip` instead.
	Ip *uint32 `protobuf:"varint,2,req,name=ip" json:"ip,omitempty"`
	// The TCP port the Master is listening on for incoming
	// HTTP requests; deprecated, use `address.port` instead.
	Port *uint32 `protobuf:"varint,3,req,name=port,def=5050" json:"port,omitempty"`
	// In the default implementation, this will contain information
	// about both the IP address, port and Master name; it should really
	// not be relied upon by external tooling/frameworks and be
	// considered an "internal" implementation field.
	Pid *string `protobuf:"bytes,4,opt,name=pid" json:"pid,omitempty"`
	// The server's hostname, if available; it may be unreliable
	// in environments where the DNS configuration does not resolve
	// internal hostnames (eg, some public cloud providers).
	// Deprecated, use `address.hostname` instead.
	Hostname *string `protobuf:"bytes,5,opt,name=hostname" json:"hostname,omitempty"`
	// The running Master version, as a string; taken from the
	// generated "master/version.hpp".
	Version *string `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
	// The full IP address (supports both IPv4 and IPv6 formats)
	// and supersedes the use of `ip`, `port` and `hostname`.
	// Since Mesos 0.24.
	Address          *Address `protobuf:"bytes,7,opt,name=address" json:"address,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *MasterInfo) Reset()                    { *m = MasterInfo{} }
func (m *MasterInfo) String() string            { return proto.CompactTextString(m) }
func (*MasterInfo) ProtoMessage()               {}
func (*MasterInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

const Default_MasterInfo_Port uint32 = 5050

func (m *MasterInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MasterInfo) GetIp() uint32 {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return 0
}

func (m *MasterInfo) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return Default_MasterInfo_Port
}

func (m *MasterInfo) GetPid() string {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return ""
}

func (m *MasterInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *MasterInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *MasterInfo) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

// *
// Describes a slave. Note that the 'id' field is only available after
// a slave is registered with the master, and is made available here
// to facilitate re-registration.  If checkpoint is set, the slave is
// checkpointing its own information and potentially frameworks'
// information (if a framework has checkpointing enabled).
type SlaveInfo struct {
	Hostname   *string      `protobuf:"bytes,1,req,name=hostname" json:"hostname,omitempty"`
	Port       *int32       `protobuf:"varint,8,opt,name=port,def=5051" json:"port,omitempty"`
	Resources  []*Resource  `protobuf:"bytes,3,rep,name=resources" json:"resources,omitempty"`
	Attributes []*Attribute `protobuf:"bytes,5,rep,name=attributes" json:"attributes,omitempty"`
	Id         *SlaveID     `protobuf:"bytes,6,opt,name=id" json:"id,omitempty"`
	// TODO(joerg84): Remove checkpoint field as with 0.22.0
	// slave checkpointing is enabled for all slaves (MESOS-2317).
	Checkpoint       *bool  `protobuf:"varint,7,opt,name=checkpoint,def=0" json:"checkpoint,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SlaveInfo) Reset()                    { *m = SlaveInfo{} }
func (m *SlaveInfo) String() string            { return proto.CompactTextString(m) }
func (*SlaveInfo) ProtoMessage()               {}
func (*SlaveInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

const Default_SlaveInfo_Port int32 = 5051
const Default_SlaveInfo_Checkpoint bool = false

func (m *SlaveInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *SlaveInfo) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return Default_SlaveInfo_Port
}

func (m *SlaveInfo) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *SlaveInfo) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *SlaveInfo) GetId() *SlaveID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SlaveInfo) GetCheckpoint() bool {
	if m != nil && m.Checkpoint != nil {
		return *m.Checkpoint
	}
	return Default_SlaveInfo_Checkpoint
}

// *
// Describes an Attribute or Resource "value". A value is described
// using the standard protocol buffer "union" trick.
type Value struct {
	Type             *Value_Type   `protobuf:"varint,1,req,name=type,enum=Value_Type" json:"type,omitempty"`
	Scalar           *Value_Scalar `protobuf:"bytes,2,opt,name=scalar" json:"scalar,omitempty"`
	Ranges           *Value_Ranges `protobuf:"bytes,3,opt,name=ranges" json:"ranges,omitempty"`
	Set              *Value_Set    `protobuf:"bytes,4,opt,name=set" json:"set,omitempty"`
	Text             *Value_Text   `protobuf:"bytes,5,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *Value) GetType() Value_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Value_SCALAR
}

func (m *Value) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Value) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Value) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Value) GetText() *Value_Text {
	if m != nil {
		return m.Text
	}
	return nil
}

type Value_Scalar struct {
	Value            *float64 `protobuf:"fixed64,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Value_Scalar) Reset()                    { *m = Value_Scalar{} }
func (m *Value_Scalar) String() string            { return proto.CompactTextString(m) }
func (*Value_Scalar) ProtoMessage()               {}
func (*Value_Scalar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67, 0} }

func (m *Value_Scalar) GetValue() float64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type Value_Range struct {
	Begin            *uint64 `protobuf:"varint,1,req,name=begin" json:"begin,omitempty"`
	End              *uint64 `protobuf:"varint,2,req,name=end" json:"end,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Value_Range) Reset()                    { *m = Value_Range{} }
func (m *Value_Range) String() string            { return proto.CompactTextString(m) }
func (*Value_Range) ProtoMessage()               {}
func (*Value_Range) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67, 1} }

func (m *Value_Range) GetBegin() uint64 {
	if m != nil && m.Begin != nil {
		return *m.Begin
	}
	return 0
}

func (m *Value_Range) GetEnd() uint64 {
	if m != nil && m.End != nil {
		return *m.End
	}
	return 0
}

type Value_Ranges struct {
	Range            []*Value_Range `protobuf:"bytes,1,rep,name=range" json:"range,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Value_Ranges) Reset()                    { *m = Value_Ranges{} }
func (m *Value_Ranges) String() string            { return proto.CompactTextString(m) }
func (*Value_Ranges) ProtoMessage()               {}
func (*Value_Ranges) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67, 2} }

func (m *Value_Ranges) GetRange() []*Value_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

type Value_Set struct {
	Item             []string `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Value_Set) Reset()                    { *m = Value_Set{} }
func (m *Value_Set) String() string            { return proto.CompactTextString(m) }
func (*Value_Set) ProtoMessage()               {}
func (*Value_Set) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67, 3} }

func (m *Value_Set) GetItem() []string {
	if m != nil {
		return m.Item
	}
	return nil
}

type Value_Text struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Value_Text) Reset()                    { *m = Value_Text{} }
func (m *Value_Text) String() string            { return proto.CompactTextString(m) }
func (*Value_Text) ProtoMessage()               {}
func (*Value_Text) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67, 4} }

func (m *Value_Text) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Describes an attribute that can be set on a machine. For now,
// attributes and resources share the same "value" type, but this may
// change in the future and attributes may only be string based.
type Attribute struct {
	Name             *string       `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Type             *Value_Type   `protobuf:"varint,2,req,name=type,enum=Value_Type" json:"type,omitempty"`
	Scalar           *Value_Scalar `protobuf:"bytes,3,opt,name=scalar" json:"scalar,omitempty"`
	Ranges           *Value_Ranges `protobuf:"bytes,4,opt,name=ranges" json:"ranges,omitempty"`
	Set              *Value_Set    `protobuf:"bytes,6,opt,name=set" json:"set,omitempty"`
	Text             *Value_Text   `protobuf:"bytes,5,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Attribute) Reset()                    { *m = Attribute{} }
func (m *Attribute) String() string            { return proto.CompactTextString(m) }
func (*Attribute) ProtoMessage()               {}
func (*Attribute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

func (m *Attribute) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Attribute) GetType() Value_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Value_SCALAR
}

func (m *Attribute) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Attribute) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Attribute) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Attribute) GetText() *Value_Text {
	if m != nil {
		return m.Text
	}
	return nil
}

// *
// Describes a resource on a machine. A resource can take on one of
// three types: scalar (double), a list of finite and discrete ranges
// (e.g., [1-10, 20-30]), or a set of items. A resource is described
// using the standard protocol buffer "union" trick.
//
// TODO(benh): Add better support for "expected" resources (e.g.,
// cpus, memory, disk, network).
type Resource struct {
	Name   *string       `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Type   *Value_Type   `protobuf:"varint,2,req,name=type,enum=Value_Type" json:"type,omitempty"`
	Scalar *Value_Scalar `protobuf:"bytes,3,opt,name=scalar" json:"scalar,omitempty"`
	Ranges *Value_Ranges `protobuf:"bytes,4,opt,name=ranges" json:"ranges,omitempty"`
	Set    *Value_Set    `protobuf:"bytes,5,opt,name=set" json:"set,omitempty"`
	Role   *string       `protobuf:"bytes,6,opt,name=role,def=*" json:"role,omitempty"`
	// If this is set, this resource was dynamically reserved by an
	// operator or a framework. Otherwise, this resource is either unreserved
	// or statically reserved by an operator via the --resources flag.
	Reservation *Resource_ReservationInfo `protobuf:"bytes,8,opt,name=reservation" json:"reservation,omitempty"`
	Disk        *Resource_DiskInfo        `protobuf:"bytes,7,opt,name=disk" json:"disk,omitempty"`
	// If this is set, the resources are revocable, i.e., any tasks or
	// executors launched using these resources could get preempted or
	// throttled at any time. This could be used by frameworks to run
	// best effort tasks that do not need strict uptime or performance
	// guarantees. Note that if this is set, 'disk' or 'reservation'
	// cannot be set.
	Revocable        *Resource_RevocableInfo `protobuf:"bytes,9,opt,name=revocable" json:"revocable,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *Resource) Reset()                    { *m = Resource{} }
func (m *Resource) String() string            { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()               {}
func (*Resource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

const Default_Resource_Role string = "*"

func (m *Resource) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Resource) GetType() Value_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Value_SCALAR
}

func (m *Resource) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Resource) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Resource) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Resource) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_Resource_Role
}

func (m *Resource) GetReservation() *Resource_ReservationInfo {
	if m != nil {
		return m.Reservation
	}
	return nil
}

func (m *Resource) GetDisk() *Resource_DiskInfo {
	if m != nil {
		return m.Disk
	}
	return nil
}

func (m *Resource) GetRevocable() *Resource_RevocableInfo {
	if m != nil {
		return m.Revocable
	}
	return nil
}

type Resource_ReservationInfo struct {
	// This field indicates the principal of the operator or framework
	// that reserved this resource. It is used in conjunction with the
	// "unreserve" ACL to determine whether the entity attempting to
	// unreserve this resource is permitted to do so.
	// NOTE: This field should match the FrameworkInfo.principal of
	// the framework that reserved this resource.
	Principal        *string `protobuf:"bytes,1,req,name=principal" json:"principal,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Resource_ReservationInfo) Reset()                    { *m = Resource_ReservationInfo{} }
func (m *Resource_ReservationInfo) String() string            { return proto.CompactTextString(m) }
func (*Resource_ReservationInfo) ProtoMessage()               {}
func (*Resource_ReservationInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69, 0} }

func (m *Resource_ReservationInfo) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

type Resource_DiskInfo struct {
	Persistence *Resource_DiskInfo_Persistence `protobuf:"bytes,1,opt,name=persistence" json:"persistence,omitempty"`
	// Describes how this disk resource will be mounted in the
	// container. If not set, the disk resource will be used as the
	// sandbox. Otherwise, it will be mounted according to the
	// 'container_path' inside 'volume'. The 'host_path' inside
	// 'volume' is ignored.
	// NOTE: If 'volume' is set but 'persistence' is not set, the
	// volume will be automatically garbage collected after
	// task/executor terminates. Currently, if 'persistence' is set,
	// 'volume' must be set.
	Volume           *Volume `protobuf:"bytes,2,opt,name=volume" json:"volume,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Resource_DiskInfo) Reset()                    { *m = Resource_DiskInfo{} }
func (m *Resource_DiskInfo) String() string            { return proto.CompactTextString(m) }
func (*Resource_DiskInfo) ProtoMessage()               {}
func (*Resource_DiskInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69, 1} }

func (m *Resource_DiskInfo) GetPersistence() *Resource_DiskInfo_Persistence {
	if m != nil {
		return m.Persistence
	}
	return nil
}

func (m *Resource_DiskInfo) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

// Describes a persistent disk volume.
// A persistent disk volume will not be automatically garbage
// collected if the task/executor/slave terminates, but is
// re-offered to the framework(s) belonging to the 'role'.
// A framework can set the ID (if it is not set yet) to express
// the intention to create a new persistent disk volume from a
// regular disk resource. To reuse a previously created volume, a
// framework can launch a task/executor when it receives an offer
// with a persistent volume, i.e., ID is set.
// NOTE: Currently, we do not allow a persistent disk volume
// without a reservation (i.e., 'role' should not be '*').
type Resource_DiskInfo_Persistence struct {
	// A unique ID for the persistent disk volume.
	// NOTE: The ID needs to be unique per role on each slave.
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Resource_DiskInfo_Persistence) Reset()         { *m = Resource_DiskInfo_Persistence{} }
func (m *Resource_DiskInfo_Persistence) String() string { return proto.CompactTextString(m) }
func (*Resource_DiskInfo_Persistence) ProtoMessage()    {}
func (*Resource_DiskInfo_Persistence) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{69, 1, 0}
}

func (m *Resource_DiskInfo_Persistence) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

type Resource_RevocableInfo struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Resource_RevocableInfo) Reset()                    { *m = Resource_RevocableInfo{} }
func (m *Resource_RevocableInfo) String() string            { return proto.CompactTextString(m) }
func (*Resource_RevocableInfo) ProtoMessage()               {}
func (*Resource_RevocableInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69, 2} }

// *
// When the network bandwidth caps are enabled and the container
// is over its limit, outbound packets may be either delayed or
// dropped completely either because it exceeds the maximum bandwidth
// allocation for a single container (the cap) or because the combined
// network traffic of multiple containers on the host exceeds the
// transmit capacity of the host (the share). We can report the
// following statistics for each of these conditions exported directly
// from the Linux Traffic Control Queueing Discipline.
//
// id         : name of the limiter, e.g. 'tx_bw_cap'
// backlog    : number of packets currently delayed
// bytes      : total bytes seen
// drops      : number of packets dropped in total
// overlimits : number of packets which exceeded allocation
// packets    : total packets seen
// qlen       : number of packets currently queued
// rate_bps   : throughput in bytes/sec
// rate_pps   : throughput in packets/sec
// requeues   : number of times a packet has been delayed due to
//              locking or device contention issues
//
// More information on the operation of Linux Traffic Control can be
// found at http://www.lartc.org/lartc.html.
type TrafficControlStatistics struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Backlog          *uint64 `protobuf:"varint,2,opt,name=backlog" json:"backlog,omitempty"`
	Bytes            *uint64 `protobuf:"varint,3,opt,name=bytes" json:"bytes,omitempty"`
	Drops            *uint64 `protobuf:"varint,4,opt,name=drops" json:"drops,omitempty"`
	Overlimits       *uint64 `protobuf:"varint,5,opt,name=overlimits" json:"overlimits,omitempty"`
	Packets          *uint64 `protobuf:"varint,6,opt,name=packets" json:"packets,omitempty"`
	Qlen             *uint64 `protobuf:"varint,7,opt,name=qlen" json:"qlen,omitempty"`
	Ratebps          *uint64 `protobuf:"varint,8,opt,name=ratebps" json:"ratebps,omitempty"`
	Ratepps          *uint64 `protobuf:"varint,9,opt,name=ratepps" json:"ratepps,omitempty"`
	Requeues         *uint64 `protobuf:"varint,10,opt,name=requeues" json:"requeues,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TrafficControlStatistics) Reset()                    { *m = TrafficControlStatistics{} }
func (m *TrafficControlStatistics) String() string            { return proto.CompactTextString(m) }
func (*TrafficControlStatistics) ProtoMessage()               {}
func (*TrafficControlStatistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{70} }

func (m *TrafficControlStatistics) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *TrafficControlStatistics) GetBacklog() uint64 {
	if m != nil && m.Backlog != nil {
		return *m.Backlog
	}
	return 0
}

func (m *TrafficControlStatistics) GetBytes() uint64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *TrafficControlStatistics) GetDrops() uint64 {
	if m != nil && m.Drops != nil {
		return *m.Drops
	}
	return 0
}

func (m *TrafficControlStatistics) GetOverlimits() uint64 {
	if m != nil && m.Overlimits != nil {
		return *m.Overlimits
	}
	return 0
}

func (m *TrafficControlStatistics) GetPackets() uint64 {
	if m != nil && m.Packets != nil {
		return *m.Packets
	}
	return 0
}

func (m *TrafficControlStatistics) GetQlen() uint64 {
	if m != nil && m.Qlen != nil {
		return *m.Qlen
	}
	return 0
}

func (m *TrafficControlStatistics) GetRatebps() uint64 {
	if m != nil && m.Ratebps != nil {
		return *m.Ratebps
	}
	return 0
}

func (m *TrafficControlStatistics) GetRatepps() uint64 {
	if m != nil && m.Ratepps != nil {
		return *m.Ratepps
	}
	return 0
}

func (m *TrafficControlStatistics) GetRequeues() uint64 {
	if m != nil && m.Requeues != nil {
		return *m.Requeues
	}
	return 0
}

// *
// A snapshot of resource usage statistics.
type ResourceStatistics struct {
	Timestamp *float64 `protobuf:"fixed64,1,req,name=timestamp" json:"timestamp,omitempty"`
	Processes *uint32  `protobuf:"varint,30,opt,name=processes" json:"processes,omitempty"`
	Threads   *uint32  `protobuf:"varint,31,opt,name=threads" json:"threads,omitempty"`
	// CPU Usage Information:
	// Total CPU time spent in user mode, and kernel mode.
	CpusUserTimeSecs   *float64 `protobuf:"fixed64,2,opt,name=cpus_user_time_secs" json:"cpus_user_time_secs,omitempty"`
	CpusSystemTimeSecs *float64 `protobuf:"fixed64,3,opt,name=cpus_system_time_secs" json:"cpus_system_time_secs,omitempty"`
	// Number of CPUs allocated.
	CpusLimit *float64 `protobuf:"fixed64,4,opt,name=cpus_limit" json:"cpus_limit,omitempty"`
	// cpu.stat on process throttling (for contention issues).
	CpusNrPeriods         *uint32  `protobuf:"varint,7,opt,name=cpus_nr_periods" json:"cpus_nr_periods,omitempty"`
	CpusNrThrottled       *uint32  `protobuf:"varint,8,opt,name=cpus_nr_throttled" json:"cpus_nr_throttled,omitempty"`
	CpusThrottledTimeSecs *float64 `protobuf:"fixed64,9,opt,name=cpus_throttled_time_secs" json:"cpus_throttled_time_secs,omitempty"`
	// mem_total_bytes was added in 0.23.0 to represent the total memory
	// of a process in RAM (as opposed to in Swap). This was previously
	// reported as mem_rss_bytes, which was also changed in 0.23.0 to
	// represent only the anonymous memory usage, to keep in sync with
	// Linux kernel's (arguably erroneous) use of terminology.
	MemTotalBytes *uint64 `protobuf:"varint,36,opt,name=mem_total_bytes" json:"mem_total_bytes,omitempty"`
	// Total memory + swap usage. This is set if swap is enabled.
	MemTotalMemswBytes *uint64 `protobuf:"varint,37,opt,name=mem_total_memsw_bytes" json:"mem_total_memsw_bytes,omitempty"`
	// Hard memory limit for a container.
	MemLimitBytes *uint64 `protobuf:"varint,6,opt,name=mem_limit_bytes" json:"mem_limit_bytes,omitempty"`
	// Soft memory limit for a container.
	MemSoftLimitBytes *uint64 `protobuf:"varint,38,opt,name=mem_soft_limit_bytes" json:"mem_soft_limit_bytes,omitempty"`
	// TODO(chzhcn) mem_file_bytes and mem_anon_bytes are deprecated in
	// 0.23.0 and will be removed in 0.24.0.
	MemFileBytes *uint64 `protobuf:"varint,10,opt,name=mem_file_bytes" json:"mem_file_bytes,omitempty"`
	MemAnonBytes *uint64 `protobuf:"varint,11,opt,name=mem_anon_bytes" json:"mem_anon_bytes,omitempty"`
	// mem_cache_bytes is added in 0.23.0 to represent page cache usage.
	MemCacheBytes *uint64 `protobuf:"varint,39,opt,name=mem_cache_bytes" json:"mem_cache_bytes,omitempty"`
	// Since 0.23.0, mem_rss_bytes is changed to represent only
	// anonymous memory usage. Note that neither its requiredness, type,
	// name nor numeric tag has been changed.
	MemRssBytes        *uint64 `protobuf:"varint,5,opt,name=mem_rss_bytes" json:"mem_rss_bytes,omitempty"`
	MemMappedFileBytes *uint64 `protobuf:"varint,12,opt,name=mem_mapped_file_bytes" json:"mem_mapped_file_bytes,omitempty"`
	// This is only set if swap is enabled.
	MemSwapBytes        *uint64 `protobuf:"varint,40,opt,name=mem_swap_bytes" json:"mem_swap_bytes,omitempty"`
	MemUnevictableBytes *uint64 `protobuf:"varint,41,opt,name=mem_unevictable_bytes" json:"mem_unevictable_bytes,omitempty"`
	// Number of occurrences of different levels of memory pressure
	// events reported by memory cgroup. Pressure listening (re)starts
	// with these values set to 0 when slave (re)starts. See
	// https://www.kernel.org/doc/Documentation/cgroups/memory.txt for
	// more details.
	MemLowPressureCounter      *uint64 `protobuf:"varint,32,opt,name=mem_low_pressure_counter" json:"mem_low_pressure_counter,omitempty"`
	MemMediumPressureCounter   *uint64 `protobuf:"varint,33,opt,name=mem_medium_pressure_counter" json:"mem_medium_pressure_counter,omitempty"`
	MemCriticalPressureCounter *uint64 `protobuf:"varint,34,opt,name=mem_critical_pressure_counter" json:"mem_critical_pressure_counter,omitempty"`
	// Disk Usage Information for executor working directory.
	DiskLimitBytes *uint64 `protobuf:"varint,26,opt,name=disk_limit_bytes" json:"disk_limit_bytes,omitempty"`
	DiskUsedBytes  *uint64 `protobuf:"varint,27,opt,name=disk_used_bytes" json:"disk_used_bytes,omitempty"`
	// Perf statistics.
	Perf *PerfStatistics `protobuf:"bytes,13,opt,name=perf" json:"perf,omitempty"`
	// Network Usage Information:
	NetRxPackets *uint64 `protobuf:"varint,14,opt,name=net_rx_packets" json:"net_rx_packets,omitempty"`
	NetRxBytes   *uint64 `protobuf:"varint,15,opt,name=net_rx_bytes" json:"net_rx_bytes,omitempty"`
	NetRxErrors  *uint64 `protobuf:"varint,16,opt,name=net_rx_errors" json:"net_rx_errors,omitempty"`
	NetRxDropped *uint64 `protobuf:"varint,17,opt,name=net_rx_dropped" json:"net_rx_dropped,omitempty"`
	NetTxPackets *uint64 `protobuf:"varint,18,opt,name=net_tx_packets" json:"net_tx_packets,omitempty"`
	NetTxBytes   *uint64 `protobuf:"varint,19,opt,name=net_tx_bytes" json:"net_tx_bytes,omitempty"`
	NetTxErrors  *uint64 `protobuf:"varint,20,opt,name=net_tx_errors" json:"net_tx_errors,omitempty"`
	NetTxDropped *uint64 `protobuf:"varint,21,opt,name=net_tx_dropped" json:"net_tx_dropped,omitempty"`
	// The kernel keeps track of RTT (round-trip time) for its TCP
	// sockets. RTT is a way to tell the latency of a container.
	NetTcpRttMicrosecsP50     *float64 `protobuf:"fixed64,22,opt,name=net_tcp_rtt_microsecs_p50" json:"net_tcp_rtt_microsecs_p50,omitempty"`
	NetTcpRttMicrosecsP90     *float64 `protobuf:"fixed64,23,opt,name=net_tcp_rtt_microsecs_p90" json:"net_tcp_rtt_microsecs_p90,omitempty"`
	NetTcpRttMicrosecsP95     *float64 `protobuf:"fixed64,24,opt,name=net_tcp_rtt_microsecs_p95" json:"net_tcp_rtt_microsecs_p95,omitempty"`
	NetTcpRttMicrosecsP99     *float64 `protobuf:"fixed64,25,opt,name=net_tcp_rtt_microsecs_p99" json:"net_tcp_rtt_microsecs_p99,omitempty"`
	NetTcpActiveConnections   *float64 `protobuf:"fixed64,28,opt,name=net_tcp_active_connections" json:"net_tcp_active_connections,omitempty"`
	NetTcpTimeWaitConnections *float64 `protobuf:"fixed64,29,opt,name=net_tcp_time_wait_connections" json:"net_tcp_time_wait_connections,omitempty"`
	// Network traffic flowing into or out of a container can be delayed
	// or dropped due to congestion or policy inside and outside the
	// container.
	NetTrafficControlStatistics []*TrafficControlStatistics `protobuf:"bytes,35,rep,name=net_traffic_control_statistics" json:"net_traffic_control_statistics,omitempty"`
	XXX_unrecognized            []byte                      `json:"-"`
}

func (m *ResourceStatistics) Reset()                    { *m = ResourceStatistics{} }
func (m *ResourceStatistics) String() string            { return proto.CompactTextString(m) }
func (*ResourceStatistics) ProtoMessage()               {}
func (*ResourceStatistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{71} }

func (m *ResourceStatistics) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *ResourceStatistics) GetProcesses() uint32 {
	if m != nil && m.Processes != nil {
		return *m.Processes
	}
	return 0
}

func (m *ResourceStatistics) GetThreads() uint32 {
	if m != nil && m.Threads != nil {
		return *m.Threads
	}
	return 0
}

func (m *ResourceStatistics) GetCpusUserTimeSecs() float64 {
	if m != nil && m.CpusUserTimeSecs != nil {
		return *m.CpusUserTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetCpusSystemTimeSecs() float64 {
	if m != nil && m.CpusSystemTimeSecs != nil {
		return *m.CpusSystemTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetCpusLimit() float64 {
	if m != nil && m.CpusLimit != nil {
		return *m.CpusLimit
	}
	return 0
}

func (m *ResourceStatistics) GetCpusNrPeriods() uint32 {
	if m != nil && m.CpusNrPeriods != nil {
		return *m.CpusNrPeriods
	}
	return 0
}

func (m *ResourceStatistics) GetCpusNrThrottled() uint32 {
	if m != nil && m.CpusNrThrottled != nil {
		return *m.CpusNrThrottled
	}
	return 0
}

func (m *ResourceStatistics) GetCpusThrottledTimeSecs() float64 {
	if m != nil && m.CpusThrottledTimeSecs != nil {
		return *m.CpusThrottledTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetMemTotalBytes() uint64 {
	if m != nil && m.MemTotalBytes != nil {
		return *m.MemTotalBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemTotalMemswBytes() uint64 {
	if m != nil && m.MemTotalMemswBytes != nil {
		return *m.MemTotalMemswBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemLimitBytes() uint64 {
	if m != nil && m.MemLimitBytes != nil {
		return *m.MemLimitBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemSoftLimitBytes() uint64 {
	if m != nil && m.MemSoftLimitBytes != nil {
		return *m.MemSoftLimitBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemFileBytes() uint64 {
	if m != nil && m.MemFileBytes != nil {
		return *m.MemFileBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemAnonBytes() uint64 {
	if m != nil && m.MemAnonBytes != nil {
		return *m.MemAnonBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemCacheBytes() uint64 {
	if m != nil && m.MemCacheBytes != nil {
		return *m.MemCacheBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemRssBytes() uint64 {
	if m != nil && m.MemRssBytes != nil {
		return *m.MemRssBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemMappedFileBytes() uint64 {
	if m != nil && m.MemMappedFileBytes != nil {
		return *m.MemMappedFileBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemSwapBytes() uint64 {
	if m != nil && m.MemSwapBytes != nil {
		return *m.MemSwapBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemUnevictableBytes() uint64 {
	if m != nil && m.MemUnevictableBytes != nil {
		return *m.MemUnevictableBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemLowPressureCounter() uint64 {
	if m != nil && m.MemLowPressureCounter != nil {
		return *m.MemLowPressureCounter
	}
	return 0
}

func (m *ResourceStatistics) GetMemMediumPressureCounter() uint64 {
	if m != nil && m.MemMediumPressureCounter != nil {
		return *m.MemMediumPressureCounter
	}
	return 0
}

func (m *ResourceStatistics) GetMemCriticalPressureCounter() uint64 {
	if m != nil && m.MemCriticalPressureCounter != nil {
		return *m.MemCriticalPressureCounter
	}
	return 0
}

func (m *ResourceStatistics) GetDiskLimitBytes() uint64 {
	if m != nil && m.DiskLimitBytes != nil {
		return *m.DiskLimitBytes
	}
	return 0
}

func (m *ResourceStatistics) GetDiskUsedBytes() uint64 {
	if m != nil && m.DiskUsedBytes != nil {
		return *m.DiskUsedBytes
	}
	return 0
}

func (m *ResourceStatistics) GetPerf() *PerfStatistics {
	if m != nil {
		return m.Perf
	}
	return nil
}

func (m *ResourceStatistics) GetNetRxPackets() uint64 {
	if m != nil && m.NetRxPackets != nil {
		return *m.NetRxPackets
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxBytes() uint64 {
	if m != nil && m.NetRxBytes != nil {
		return *m.NetRxBytes
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxErrors() uint64 {
	if m != nil && m.NetRxErrors != nil {
		return *m.NetRxErrors
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxDropped() uint64 {
	if m != nil && m.NetRxDropped != nil {
		return *m.NetRxDropped
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxPackets() uint64 {
	if m != nil && m.NetTxPackets != nil {
		return *m.NetTxPackets
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxBytes() uint64 {
	if m != nil && m.NetTxBytes != nil {
		return *m.NetTxBytes
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxErrors() uint64 {
	if m != nil && m.NetTxErrors != nil {
		return *m.NetTxErrors
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxDropped() uint64 {
	if m != nil && m.NetTxDropped != nil {
		return *m.NetTxDropped
	}
	return 0
}

func (m *ResourceStatistics) GetNetTcpRttMicrosecsP50() float64 {
	if m != nil && m.NetTcpRttMicrosecsP50 != nil {
		return *m.NetTcpRttMicrosecsP50
	}
	return 0
}

func (m *ResourceStatistics) GetNetTcpRttMicrosecsP90() float64 {
	if m != nil && m.NetTcpRttMicrosecsP90 != nil {
		return *m.NetTcpRttMicrosecsP90
	}
	return 0
}

func (m *ResourceStatistics) GetNetTcpRttMicrosecsP95() float64 {
	if m != nil && m.NetTcpRttMicrosecsP95 != nil {
		return *m.NetTcpRttMicrosecsP95
	}
	return 0
}

func (m *ResourceStatistics) GetNetTcpRttMicrosecsP99() float64 {
	if m != nil && m.NetTcpRttMicrosecsP99 != nil {
		return *m.NetTcpRttMicrosecsP99
	}
	return 0
}

func (m *ResourceStatistics) GetNetTcpActiveConnections() float64 {
	if m != nil && m.NetTcpActiveConnections != nil {
		return *m.NetTcpActiveConnections
	}
	return 0
}

func (m *ResourceStatistics) GetNetTcpTimeWaitConnections() float64 {
	if m != nil && m.NetTcpTimeWaitConnections != nil {
		return *m.NetTcpTimeWaitConnections
	}
	return 0
}

func (m *ResourceStatistics) GetNetTrafficControlStatistics() []*TrafficControlStatistics {
	if m != nil {
		return m.NetTrafficControlStatistics
	}
	return nil
}

// *
// Describes a snapshot of the resource usage for executors.
type ResourceUsage struct {
	Executors []*ResourceUsage_Executor `protobuf:"bytes,1,rep,name=executors" json:"executors,omitempty"`
	// Slave's total resources including checkpointed dynamic
	// reservations and persistent volumes.
	Total            []*Resource `protobuf:"bytes,2,rep,name=total" json:"total,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ResourceUsage) Reset()                    { *m = ResourceUsage{} }
func (m *ResourceUsage) String() string            { return proto.CompactTextString(m) }
func (*ResourceUsage) ProtoMessage()               {}
func (*ResourceUsage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72} }

func (m *ResourceUsage) GetExecutors() []*ResourceUsage_Executor {
	if m != nil {
		return m.Executors
	}
	return nil
}

func (m *ResourceUsage) GetTotal() []*Resource {
	if m != nil {
		return m.Total
	}
	return nil
}

type ResourceUsage_Executor struct {
	ExecutorInfo *ExecutorInfo `protobuf:"bytes,1,req,name=executor_info" json:"executor_info,omitempty"`
	// This includes resources used by the executor itself
	// as well as its active tasks.
	Allocated []*Resource `protobuf:"bytes,2,rep,name=allocated" json:"allocated,omitempty"`
	// Current resource usage. If absent, the containerizer
	// cannot provide resource usage.
	Statistics *ResourceStatistics `protobuf:"bytes,3,opt,name=statistics" json:"statistics,omitempty"`
	// The container id for the executor specified in the executor_info field.
	ContainerId      *ContainerID `protobuf:"bytes,4,req,name=container_id" json:"container_id,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ResourceUsage_Executor) Reset()                    { *m = ResourceUsage_Executor{} }
func (m *ResourceUsage_Executor) String() string            { return proto.CompactTextString(m) }
func (*ResourceUsage_Executor) ProtoMessage()               {}
func (*ResourceUsage_Executor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72, 0} }

func (m *ResourceUsage_Executor) GetExecutorInfo() *ExecutorInfo {
	if m != nil {
		return m.ExecutorInfo
	}
	return nil
}

func (m *ResourceUsage_Executor) GetAllocated() []*Resource {
	if m != nil {
		return m.Allocated
	}
	return nil
}

func (m *ResourceUsage_Executor) GetStatistics() *ResourceStatistics {
	if m != nil {
		return m.Statistics
	}
	return nil
}

func (m *ResourceUsage_Executor) GetContainerId() *ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

// *
// Describes a sample of events from "perf stat". Only available on
// Linux.
//
// NOTE: Each optional field matches the name of a perf event (see
// "perf list") with the following changes:
// 1. Names are downcased.
// 2. Hyphens ('-') are replaced with underscores ('_').
// 3. Events with alternate names use the name "perf stat" returns,
//    e.g., for the event "cycles OR cpu-cycles" perf always returns
//    cycles.
type PerfStatistics struct {
	Timestamp *float64 `protobuf:"fixed64,1,req,name=timestamp" json:"timestamp,omitempty"`
	Duration  *float64 `protobuf:"fixed64,2,req,name=duration" json:"duration,omitempty"`
	// Hardware event.
	Cycles                *uint64 `protobuf:"varint,3,opt,name=cycles" json:"cycles,omitempty"`
	StalledCyclesFrontend *uint64 `protobuf:"varint,4,opt,name=stalled_cycles_frontend" json:"stalled_cycles_frontend,omitempty"`
	StalledCyclesBackend  *uint64 `protobuf:"varint,5,opt,name=stalled_cycles_backend" json:"stalled_cycles_backend,omitempty"`
	Instructions          *uint64 `protobuf:"varint,6,opt,name=instructions" json:"instructions,omitempty"`
	CacheReferences       *uint64 `protobuf:"varint,7,opt,name=cache_references" json:"cache_references,omitempty"`
	CacheMisses           *uint64 `protobuf:"varint,8,opt,name=cache_misses" json:"cache_misses,omitempty"`
	Branches              *uint64 `protobuf:"varint,9,opt,name=branches" json:"branches,omitempty"`
	BranchMisses          *uint64 `protobuf:"varint,10,opt,name=branch_misses" json:"branch_misses,omitempty"`
	BusCycles             *uint64 `protobuf:"varint,11,opt,name=bus_cycles" json:"bus_cycles,omitempty"`
	RefCycles             *uint64 `protobuf:"varint,12,opt,name=ref_cycles" json:"ref_cycles,omitempty"`
	// Software event.
	CpuClock        *float64 `protobuf:"fixed64,13,opt,name=cpu_clock" json:"cpu_clock,omitempty"`
	TaskClock       *float64 `protobuf:"fixed64,14,opt,name=task_clock" json:"task_clock,omitempty"`
	PageFaults      *uint64  `protobuf:"varint,15,opt,name=page_faults" json:"page_faults,omitempty"`
	MinorFaults     *uint64  `protobuf:"varint,16,opt,name=minor_faults" json:"minor_faults,omitempty"`
	MajorFaults     *uint64  `protobuf:"varint,17,opt,name=major_faults" json:"major_faults,omitempty"`
	ContextSwitches *uint64  `protobuf:"varint,18,opt,name=context_switches" json:"context_switches,omitempty"`
	CpuMigrations   *uint64  `protobuf:"varint,19,opt,name=cpu_migrations" json:"cpu_migrations,omitempty"`
	AlignmentFaults *uint64  `protobuf:"varint,20,opt,name=alignment_faults" json:"alignment_faults,omitempty"`
	EmulationFaults *uint64  `protobuf:"varint,21,opt,name=emulation_faults" json:"emulation_faults,omitempty"`
	// Hardware cache event.
	L1DcacheLoads          *uint64 `protobuf:"varint,22,opt,name=l1_dcache_loads" json:"l1_dcache_loads,omitempty"`
	L1DcacheLoadMisses     *uint64 `protobuf:"varint,23,opt,name=l1_dcache_load_misses" json:"l1_dcache_load_misses,omitempty"`
	L1DcacheStores         *uint64 `protobuf:"varint,24,opt,name=l1_dcache_stores" json:"l1_dcache_stores,omitempty"`
	L1DcacheStoreMisses    *uint64 `protobuf:"varint,25,opt,name=l1_dcache_store_misses" json:"l1_dcache_store_misses,omitempty"`
	L1DcachePrefetches     *uint64 `protobuf:"varint,26,opt,name=l1_dcache_prefetches" json:"l1_dcache_prefetches,omitempty"`
	L1DcachePrefetchMisses *uint64 `protobuf:"varint,27,opt,name=l1_dcache_prefetch_misses" json:"l1_dcache_prefetch_misses,omitempty"`
	L1IcacheLoads          *uint64 `protobuf:"varint,28,opt,name=l1_icache_loads" json:"l1_icache_loads,omitempty"`
	L1IcacheLoadMisses     *uint64 `protobuf:"varint,29,opt,name=l1_icache_load_misses" json:"l1_icache_load_misses,omitempty"`
	L1IcachePrefetches     *uint64 `protobuf:"varint,30,opt,name=l1_icache_prefetches" json:"l1_icache_prefetches,omitempty"`
	L1IcachePrefetchMisses *uint64 `protobuf:"varint,31,opt,name=l1_icache_prefetch_misses" json:"l1_icache_prefetch_misses,omitempty"`
	LlcLoads               *uint64 `protobuf:"varint,32,opt,name=llc_loads" json:"llc_loads,omitempty"`
	LlcLoadMisses          *uint64 `protobuf:"varint,33,opt,name=llc_load_misses" json:"llc_load_misses,omitempty"`
	LlcStores              *uint64 `protobuf:"varint,34,opt,name=llc_stores" json:"llc_stores,omitempty"`
	LlcStoreMisses         *uint64 `protobuf:"varint,35,opt,name=llc_store_misses" json:"llc_store_misses,omitempty"`
	LlcPrefetches          *uint64 `protobuf:"varint,36,opt,name=llc_prefetches" json:"llc_prefetches,omitempty"`
	LlcPrefetchMisses      *uint64 `protobuf:"varint,37,opt,name=llc_prefetch_misses" json:"llc_prefetch_misses,omitempty"`
	DtlbLoads              *uint64 `protobuf:"varint,38,opt,name=dtlb_loads" json:"dtlb_loads,omitempty"`
	DtlbLoadMisses         *uint64 `protobuf:"varint,39,opt,name=dtlb_load_misses" json:"dtlb_load_misses,omitempty"`
	DtlbStores             *uint64 `protobuf:"varint,40,opt,name=dtlb_stores" json:"dtlb_stores,omitempty"`
	DtlbStoreMisses        *uint64 `protobuf:"varint,41,opt,name=dtlb_store_misses" json:"dtlb_store_misses,omitempty"`
	DtlbPrefetches         *uint64 `protobuf:"varint,42,opt,name=dtlb_prefetches" json:"dtlb_prefetches,omitempty"`
	DtlbPrefetchMisses     *uint64 `protobuf:"varint,43,opt,name=dtlb_prefetch_misses" json:"dtlb_prefetch_misses,omitempty"`
	ItlbLoads              *uint64 `protobuf:"varint,44,opt,name=itlb_loads" json:"itlb_loads,omitempty"`
	ItlbLoadMisses         *uint64 `protobuf:"varint,45,opt,name=itlb_load_misses" json:"itlb_load_misses,omitempty"`
	BranchLoads            *uint64 `protobuf:"varint,46,opt,name=branch_loads" json:"branch_loads,omitempty"`
	BranchLoadMisses       *uint64 `protobuf:"varint,47,opt,name=branch_load_misses" json:"branch_load_misses,omitempty"`
	NodeLoads              *uint64 `protobuf:"varint,48,opt,name=node_loads" json:"node_loads,omitempty"`
	NodeLoadMisses         *uint64 `protobuf:"varint,49,opt,name=node_load_misses" json:"node_load_misses,omitempty"`
	NodeStores             *uint64 `protobuf:"varint,50,opt,name=node_stores" json:"node_stores,omitempty"`
	NodeStoreMisses        *uint64 `protobuf:"varint,51,opt,name=node_store_misses" json:"node_store_misses,omitempty"`
	NodePrefetches         *uint64 `protobuf:"varint,52,opt,name=node_prefetches" json:"node_prefetches,omitempty"`
	NodePrefetchMisses     *uint64 `protobuf:"varint,53,opt,name=node_prefetch_misses" json:"node_prefetch_misses,omitempty"`
	XXX_unrecognized       []byte  `json:"-"`
}

func (m *PerfStatistics) Reset()                    { *m = PerfStatistics{} }
func (m *PerfStatistics) String() string            { return proto.CompactTextString(m) }
func (*PerfStatistics) ProtoMessage()               {}
func (*PerfStatistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{73} }

func (m *PerfStatistics) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *PerfStatistics) GetDuration() float64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *PerfStatistics) GetCycles() uint64 {
	if m != nil && m.Cycles != nil {
		return *m.Cycles
	}
	return 0
}

func (m *PerfStatistics) GetStalledCyclesFrontend() uint64 {
	if m != nil && m.StalledCyclesFrontend != nil {
		return *m.StalledCyclesFrontend
	}
	return 0
}

func (m *PerfStatistics) GetStalledCyclesBackend() uint64 {
	if m != nil && m.StalledCyclesBackend != nil {
		return *m.StalledCyclesBackend
	}
	return 0
}

func (m *PerfStatistics) GetInstructions() uint64 {
	if m != nil && m.Instructions != nil {
		return *m.Instructions
	}
	return 0
}

func (m *PerfStatistics) GetCacheReferences() uint64 {
	if m != nil && m.CacheReferences != nil {
		return *m.CacheReferences
	}
	return 0
}

func (m *PerfStatistics) GetCacheMisses() uint64 {
	if m != nil && m.CacheMisses != nil {
		return *m.CacheMisses
	}
	return 0
}

func (m *PerfStatistics) GetBranches() uint64 {
	if m != nil && m.Branches != nil {
		return *m.Branches
	}
	return 0
}

func (m *PerfStatistics) GetBranchMisses() uint64 {
	if m != nil && m.BranchMisses != nil {
		return *m.BranchMisses
	}
	return 0
}

func (m *PerfStatistics) GetBusCycles() uint64 {
	if m != nil && m.BusCycles != nil {
		return *m.BusCycles
	}
	return 0
}

func (m *PerfStatistics) GetRefCycles() uint64 {
	if m != nil && m.RefCycles != nil {
		return *m.RefCycles
	}
	return 0
}

func (m *PerfStatistics) GetCpuClock() float64 {
	if m != nil && m.CpuClock != nil {
		return *m.CpuClock
	}
	return 0
}

func (m *PerfStatistics) GetTaskClock() float64 {
	if m != nil && m.TaskClock != nil {
		return *m.TaskClock
	}
	return 0
}

func (m *PerfStatistics) GetPageFaults() uint64 {
	if m != nil && m.PageFaults != nil {
		return *m.PageFaults
	}
	return 0
}

func (m *PerfStatistics) GetMinorFaults() uint64 {
	if m != nil && m.MinorFaults != nil {
		return *m.MinorFaults
	}
	return 0
}

func (m *PerfStatistics) GetMajorFaults() uint64 {
	if m != nil && m.MajorFaults != nil {
		return *m.MajorFaults
	}
	return 0
}

func (m *PerfStatistics) GetContextSwitches() uint64 {
	if m != nil && m.ContextSwitches != nil {
		return *m.ContextSwitches
	}
	return 0
}

func (m *PerfStatistics) GetCpuMigrations() uint64 {
	if m != nil && m.CpuMigrations != nil {
		return *m.CpuMigrations
	}
	return 0
}

func (m *PerfStatistics) GetAlignmentFaults() uint64 {
	if m != nil && m.AlignmentFaults != nil {
		return *m.AlignmentFaults
	}
	return 0
}

func (m *PerfStatistics) GetEmulationFaults() uint64 {
	if m != nil && m.EmulationFaults != nil {
		return *m.EmulationFaults
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheLoads() uint64 {
	if m != nil && m.L1DcacheLoads != nil {
		return *m.L1DcacheLoads
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheLoadMisses() uint64 {
	if m != nil && m.L1DcacheLoadMisses != nil {
		return *m.L1DcacheLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheStores() uint64 {
	if m != nil && m.L1DcacheStores != nil {
		return *m.L1DcacheStores
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheStoreMisses() uint64 {
	if m != nil && m.L1DcacheStoreMisses != nil {
		return *m.L1DcacheStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1DcachePrefetches() uint64 {
	if m != nil && m.L1DcachePrefetches != nil {
		return *m.L1DcachePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetL1DcachePrefetchMisses() uint64 {
	if m != nil && m.L1DcachePrefetchMisses != nil {
		return *m.L1DcachePrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1IcacheLoads() uint64 {
	if m != nil && m.L1IcacheLoads != nil {
		return *m.L1IcacheLoads
	}
	return 0
}

func (m *PerfStatistics) GetL1IcacheLoadMisses() uint64 {
	if m != nil && m.L1IcacheLoadMisses != nil {
		return *m.L1IcacheLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1IcachePrefetches() uint64 {
	if m != nil && m.L1IcachePrefetches != nil {
		return *m.L1IcachePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetL1IcachePrefetchMisses() uint64 {
	if m != nil && m.L1IcachePrefetchMisses != nil {
		return *m.L1IcachePrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetLlcLoads() uint64 {
	if m != nil && m.LlcLoads != nil {
		return *m.LlcLoads
	}
	return 0
}

func (m *PerfStatistics) GetLlcLoadMisses() uint64 {
	if m != nil && m.LlcLoadMisses != nil {
		return *m.LlcLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetLlcStores() uint64 {
	if m != nil && m.LlcStores != nil {
		return *m.LlcStores
	}
	return 0
}

func (m *PerfStatistics) GetLlcStoreMisses() uint64 {
	if m != nil && m.LlcStoreMisses != nil {
		return *m.LlcStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetLlcPrefetches() uint64 {
	if m != nil && m.LlcPrefetches != nil {
		return *m.LlcPrefetches
	}
	return 0
}

func (m *PerfStatistics) GetLlcPrefetchMisses() uint64 {
	if m != nil && m.LlcPrefetchMisses != nil {
		return *m.LlcPrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetDtlbLoads() uint64 {
	if m != nil && m.DtlbLoads != nil {
		return *m.DtlbLoads
	}
	return 0
}

func (m *PerfStatistics) GetDtlbLoadMisses() uint64 {
	if m != nil && m.DtlbLoadMisses != nil {
		return *m.DtlbLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetDtlbStores() uint64 {
	if m != nil && m.DtlbStores != nil {
		return *m.DtlbStores
	}
	return 0
}

func (m *PerfStatistics) GetDtlbStoreMisses() uint64 {
	if m != nil && m.DtlbStoreMisses != nil {
		return *m.DtlbStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetDtlbPrefetches() uint64 {
	if m != nil && m.DtlbPrefetches != nil {
		return *m.DtlbPrefetches
	}
	return 0
}

func (m *PerfStatistics) GetDtlbPrefetchMisses() uint64 {
	if m != nil && m.DtlbPrefetchMisses != nil {
		return *m.DtlbPrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetItlbLoads() uint64 {
	if m != nil && m.ItlbLoads != nil {
		return *m.ItlbLoads
	}
	return 0
}

func (m *PerfStatistics) GetItlbLoadMisses() uint64 {
	if m != nil && m.ItlbLoadMisses != nil {
		return *m.ItlbLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetBranchLoads() uint64 {
	if m != nil && m.BranchLoads != nil {
		return *m.BranchLoads
	}
	return 0
}

func (m *PerfStatistics) GetBranchLoadMisses() uint64 {
	if m != nil && m.BranchLoadMisses != nil {
		return *m.BranchLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodeLoads() uint64 {
	if m != nil && m.NodeLoads != nil {
		return *m.NodeLoads
	}
	return 0
}

func (m *PerfStatistics) GetNodeLoadMisses() uint64 {
	if m != nil && m.NodeLoadMisses != nil {
		return *m.NodeLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodeStores() uint64 {
	if m != nil && m.NodeStores != nil {
		return *m.NodeStores
	}
	return 0
}

func (m *PerfStatistics) GetNodeStoreMisses() uint64 {
	if m != nil && m.NodeStoreMisses != nil {
		return *m.NodeStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodePrefetches() uint64 {
	if m != nil && m.NodePrefetches != nil {
		return *m.NodePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetNodePrefetchMisses() uint64 {
	if m != nil && m.NodePrefetchMisses != nil {
		return *m.NodePrefetchMisses
	}
	return 0
}

// *
// Describes a request for resources that can be used by a framework
// to proactively influence the allocator.  If 'slave_id' is provided
// then this request is assumed to only apply to resources on that
// slave.
type Request struct {
	SlaveId          *SlaveID    `protobuf:"bytes,1,opt,name=slave_id" json:"slave_id,omitempty"`
	Resources        []*Resource `protobuf:"bytes,2,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{74} }

func (m *Request) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *Request) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// Describes some resources available on a slave. An offer only
// contains resources from a single slave.
type Offer struct {
	Id          *OfferID     `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	FrameworkId *FrameworkID `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	SlaveId     *SlaveID     `protobuf:"bytes,3,req,name=slave_id" json:"slave_id,omitempty"`
	Hostname    *string      `protobuf:"bytes,4,req,name=hostname" json:"hostname,omitempty"`
	// URL for reaching the slave running on the host.
	Url         *URL          `protobuf:"bytes,8,opt,name=url" json:"url,omitempty"`
	Resources   []*Resource   `protobuf:"bytes,5,rep,name=resources" json:"resources,omitempty"`
	Attributes  []*Attribute  `protobuf:"bytes,7,rep,name=attributes" json:"attributes,omitempty"`
	ExecutorIds []*ExecutorID `protobuf:"bytes,6,rep,name=executor_ids" json:"executor_ids,omitempty"`
	// Signifies that the resources in this Offer may be unavailable during
	// the given interval.  Any tasks launched using these resources may be
	// killed when the interval arrives.  For example, these resources may be
	// part of a planned maintenance schedule.
	//
	// This field only provides information about a planned unavailability.
	// The unavailability interval may not necessarily start at exactly this
	// interval, nor last for exactly the duration of this interval.
	// The unavailability may also be forever!  See comments in
	// `Unavailability` for more details.
	Unavailability   *Unavailability `protobuf:"bytes,9,opt,name=unavailability" json:"unavailability,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Offer) Reset()                    { *m = Offer{} }
func (m *Offer) String() string            { return proto.CompactTextString(m) }
func (*Offer) ProtoMessage()               {}
func (*Offer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75} }

func (m *Offer) GetId() *OfferID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Offer) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *Offer) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *Offer) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Offer) GetUrl() *URL {
	if m != nil {
		return m.Url
	}
	return nil
}

func (m *Offer) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Offer) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Offer) GetExecutorIds() []*ExecutorID {
	if m != nil {
		return m.ExecutorIds
	}
	return nil
}

func (m *Offer) GetUnavailability() *Unavailability {
	if m != nil {
		return m.Unavailability
	}
	return nil
}

// Defines an operation that can be performed against offers.
type Offer_Operation struct {
	Type             *Offer_Operation_Type      `protobuf:"varint,1,req,name=type,enum=Offer_Operation_Type" json:"type,omitempty"`
	Launch           *Offer_Operation_Launch    `protobuf:"bytes,2,opt,name=launch" json:"launch,omitempty"`
	Reserve          *Offer_Operation_Reserve   `protobuf:"bytes,3,opt,name=reserve" json:"reserve,omitempty"`
	Unreserve        *Offer_Operation_Unreserve `protobuf:"bytes,4,opt,name=unreserve" json:"unreserve,omitempty"`
	Create           *Offer_Operation_Create    `protobuf:"bytes,5,opt,name=create" json:"create,omitempty"`
	Destroy          *Offer_Operation_Destroy   `protobuf:"bytes,6,opt,name=destroy" json:"destroy,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Offer_Operation) Reset()                    { *m = Offer_Operation{} }
func (m *Offer_Operation) String() string            { return proto.CompactTextString(m) }
func (*Offer_Operation) ProtoMessage()               {}
func (*Offer_Operation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75, 0} }

func (m *Offer_Operation) GetType() Offer_Operation_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Offer_Operation_LAUNCH
}

func (m *Offer_Operation) GetLaunch() *Offer_Operation_Launch {
	if m != nil {
		return m.Launch
	}
	return nil
}

func (m *Offer_Operation) GetReserve() *Offer_Operation_Reserve {
	if m != nil {
		return m.Reserve
	}
	return nil
}

func (m *Offer_Operation) GetUnreserve() *Offer_Operation_Unreserve {
	if m != nil {
		return m.Unreserve
	}
	return nil
}

func (m *Offer_Operation) GetCreate() *Offer_Operation_Create {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *Offer_Operation) GetDestroy() *Offer_Operation_Destroy {
	if m != nil {
		return m.Destroy
	}
	return nil
}

type Offer_Operation_Launch struct {
	TaskInfos        []*TaskInfo `protobuf:"bytes,1,rep,name=task_infos" json:"task_infos,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Offer_Operation_Launch) Reset()                    { *m = Offer_Operation_Launch{} }
func (m *Offer_Operation_Launch) String() string            { return proto.CompactTextString(m) }
func (*Offer_Operation_Launch) ProtoMessage()               {}
func (*Offer_Operation_Launch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75, 0, 0} }

func (m *Offer_Operation_Launch) GetTaskInfos() []*TaskInfo {
	if m != nil {
		return m.TaskInfos
	}
	return nil
}

type Offer_Operation_Reserve struct {
	Resources        []*Resource `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Offer_Operation_Reserve) Reset()                    { *m = Offer_Operation_Reserve{} }
func (m *Offer_Operation_Reserve) String() string            { return proto.CompactTextString(m) }
func (*Offer_Operation_Reserve) ProtoMessage()               {}
func (*Offer_Operation_Reserve) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75, 0, 1} }

func (m *Offer_Operation_Reserve) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Offer_Operation_Unreserve struct {
	Resources        []*Resource `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Offer_Operation_Unreserve) Reset()         { *m = Offer_Operation_Unreserve{} }
func (m *Offer_Operation_Unreserve) String() string { return proto.CompactTextString(m) }
func (*Offer_Operation_Unreserve) ProtoMessage()    {}
func (*Offer_Operation_Unreserve) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{75, 0, 2}
}

func (m *Offer_Operation_Unreserve) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Offer_Operation_Create struct {
	Volumes          []*Resource `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Offer_Operation_Create) Reset()                    { *m = Offer_Operation_Create{} }
func (m *Offer_Operation_Create) String() string            { return proto.CompactTextString(m) }
func (*Offer_Operation_Create) ProtoMessage()               {}
func (*Offer_Operation_Create) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75, 0, 3} }

func (m *Offer_Operation_Create) GetVolumes() []*Resource {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type Offer_Operation_Destroy struct {
	Volumes          []*Resource `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Offer_Operation_Destroy) Reset()                    { *m = Offer_Operation_Destroy{} }
func (m *Offer_Operation_Destroy) String() string            { return proto.CompactTextString(m) }
func (*Offer_Operation_Destroy) ProtoMessage()               {}
func (*Offer_Operation_Destroy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75, 0, 4} }

func (m *Offer_Operation_Destroy) GetVolumes() []*Resource {
	if m != nil {
		return m.Volumes
	}
	return nil
}

// *
// A request to return some resources occupied by a framework.
type InverseOffer struct {
	// This is the same OfferID as found in normal offers, which allows
	// re-use of some of the OfferID-only messages.
	Id *OfferID `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// URL for reaching the slave running on the host.  This enables some
	// optimizations as described in MESOS-3012, such as allowing the
	// scheduler driver to bypass the master and talk directly with a slave.
	Url *URL `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
	// The framework that should release its resources.
	// If no specifics are provided (i.e. which slave), all the framework's
	// resources are requested back.
	FrameworkId *FrameworkID `protobuf:"bytes,3,req,name=framework_id" json:"framework_id,omitempty"`
	// Specified if the resources need to be released from a particular slave.
	// All the framework's resources on this slave are requested back,
	// unless further qualified by the `resources` field.
	SlaveId *SlaveID `protobuf:"bytes,4,opt,name=slave_id" json:"slave_id,omitempty"`
	// This InverseOffer represents a planned unavailability event in the
	// specified interval.  Any tasks running on the given framework or slave
	// may be killed when the interval arrives.  Therefore, frameworks should
	// aim to gracefully terminate tasks prior to the arrival of the interval.
	//
	// For reserved resources, the resources are expected to be returned to the
	// framework after the unavailability interval.  This is an expectation,
	// not a guarantee.  For example, if the unavailability duration is not set,
	// the resources may be removed permanently.
	//
	// For other resources, there is no guarantee that requested resources will
	// be returned after the unavailability interval.  The allocator has no
	// obligation to re-offer these resources to the prior framework after
	// the unavailability.
	Unavailability *Unavailability `protobuf:"bytes,5,req,name=unavailability" json:"unavailability,omitempty"`
	// A list of resources being requested back from the framework,
	// on the slave identified by `slave_id`.  If no resources are specified
	// then all resources are being requested back.  For the purpose of
	// maintenance, this field is always empty (maintenance always requests
	// all resources back).
	Resources        []*Resource `protobuf:"bytes,6,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *InverseOffer) Reset()                    { *m = InverseOffer{} }
func (m *InverseOffer) String() string            { return proto.CompactTextString(m) }
func (*InverseOffer) ProtoMessage()               {}
func (*InverseOffer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{76} }

func (m *InverseOffer) GetId() *OfferID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *InverseOffer) GetUrl() *URL {
	if m != nil {
		return m.Url
	}
	return nil
}

func (m *InverseOffer) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *InverseOffer) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *InverseOffer) GetUnavailability() *Unavailability {
	if m != nil {
		return m.Unavailability
	}
	return nil
}

func (m *InverseOffer) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// Describes a task. Passed from the scheduler all the way to an
// executor (see SchedulerDriver::launchTasks and
// Executor::launchTask). Either ExecutorInfo or CommandInfo should be set.
// A different executor can be used to launch this task, and subsequent tasks
// meant for the same executor can reuse the same ExecutorInfo struct.
type TaskInfo struct {
	Name      *string       `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	TaskId    *TaskID       `protobuf:"bytes,2,req,name=task_id" json:"task_id,omitempty"`
	SlaveId   *SlaveID      `protobuf:"bytes,3,req,name=slave_id" json:"slave_id,omitempty"`
	Resources []*Resource   `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	Executor  *ExecutorInfo `protobuf:"bytes,5,opt,name=executor" json:"executor,omitempty"`
	Command   *CommandInfo  `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	// Task provided with a container will launch the container as part
	// of this task paired with the task's CommandInfo.
	Container *ContainerInfo `protobuf:"bytes,9,opt,name=container" json:"container,omitempty"`
	Data      []byte         `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	// A health check for the task (currently in *alpha* and initial
	// support will only be for TaskInfo's that have a CommandInfo).
	HealthCheck *HealthCheck `protobuf:"bytes,8,opt,name=health_check" json:"health_check,omitempty"`
	// Labels are free-form key value pairs which are exposed through
	// master and slave endpoints. Labels will not be interpreted or
	// acted upon by Mesos itself. As opposed to the data field, labels
	// will be kept in memory on master and slave processes. Therefore,
	// labels should be used to tag tasks with light-weight meta-data.
	Labels *Labels `protobuf:"bytes,10,opt,name=labels" json:"labels,omitempty"`
	// Service discovery information for the task. It is not interpreted
	// or acted upon by Mesos. It is up to a service discovery system
	// to use this information as needed and to handle tasks without
	// service discovery information.
	Discovery        *DiscoveryInfo `protobuf:"bytes,11,opt,name=discovery" json:"discovery,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *TaskInfo) Reset()                    { *m = TaskInfo{} }
func (m *TaskInfo) String() string            { return proto.CompactTextString(m) }
func (*TaskInfo) ProtoMessage()               {}
func (*TaskInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{77} }

func (m *TaskInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TaskInfo) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *TaskInfo) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *TaskInfo) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TaskInfo) GetExecutor() *ExecutorInfo {
	if m != nil {
		return m.Executor
	}
	return nil
}

func (m *TaskInfo) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *TaskInfo) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *TaskInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TaskInfo) GetHealthCheck() *HealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func (m *TaskInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TaskInfo) GetDiscovery() *DiscoveryInfo {
	if m != nil {
		return m.Discovery
	}
	return nil
}

// *
// Describes the current status of a task.
type TaskStatus struct {
	TaskId     *TaskID            `protobuf:"bytes,1,req,name=task_id" json:"task_id,omitempty"`
	State      *TaskState         `protobuf:"varint,2,req,name=state,enum=TaskState" json:"state,omitempty"`
	Message    *string            `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	Source     *TaskStatus_Source `protobuf:"varint,9,opt,name=source,enum=TaskStatus_Source" json:"source,omitempty"`
	Reason     *TaskStatus_Reason `protobuf:"varint,10,opt,name=reason,enum=TaskStatus_Reason" json:"reason,omitempty"`
	Data       []byte             `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	SlaveId    *SlaveID           `protobuf:"bytes,5,opt,name=slave_id" json:"slave_id,omitempty"`
	ExecutorId *ExecutorID        `protobuf:"bytes,7,opt,name=executor_id" json:"executor_id,omitempty"`
	Timestamp  *float64           `protobuf:"fixed64,6,opt,name=timestamp" json:"timestamp,omitempty"`
	// Statuses that are delivered reliably to the scheduler will
	// include a 'uuid'. The status is considered delivered once
	// it is acknowledged by the scheduler. Schedulers can choose
	// to either explicitly acknowledge statuses or let the scheduler
	// driver implicitly acknowledge (default).
	//
	// TODO(bmahler): This is currently overwritten in the scheduler
	// driver and executor driver, but executors will need to set this
	// to a valid RFC-4122 UUID if using the HTTP API.
	Uuid []byte `protobuf:"bytes,11,opt,name=uuid" json:"uuid,omitempty"`
	// Describes whether the task has been determined to be healthy
	// (true) or unhealthy (false) according to the HealthCheck field in
	// the command info.
	Healthy *bool `protobuf:"varint,8,opt,name=healthy" json:"healthy,omitempty"`
	// Labels are free-form key value pairs which are exposed through
	// master and slave endpoints. Labels will not be interpreted or
	// acted upon by Mesos itself. As opposed to the data field, labels
	// will be kept in memory on master and slave processes. Therefore,
	// labels should be used to tag TaskStatus message with light-weight
	// meta-data.
	Labels *Labels `protobuf:"bytes,12,opt,name=labels" json:"labels,omitempty"`
	// Container related information that is resolved dynamically such as
	// network address.
	ContainerStatus  *ContainerStatus `protobuf:"bytes,13,opt,name=container_status" json:"container_status,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *TaskStatus) Reset()                    { *m = TaskStatus{} }
func (m *TaskStatus) String() string            { return proto.CompactTextString(m) }
func (*TaskStatus) ProtoMessage()               {}
func (*TaskStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{78} }

func (m *TaskStatus) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *TaskStatus) GetState() TaskState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return TaskState_TASK_STAGING
}

func (m *TaskStatus) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *TaskStatus) GetSource() TaskStatus_Source {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return TaskStatus_SOURCE_MASTER
}

func (m *TaskStatus) GetReason() TaskStatus_Reason {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return TaskStatus_REASON_COMMAND_EXECUTOR_FAILED
}

func (m *TaskStatus) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TaskStatus) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *TaskStatus) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *TaskStatus) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *TaskStatus) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *TaskStatus) GetHealthy() bool {
	if m != nil && m.Healthy != nil {
		return *m.Healthy
	}
	return false
}

func (m *TaskStatus) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TaskStatus) GetContainerStatus() *ContainerStatus {
	if m != nil {
		return m.ContainerStatus
	}
	return nil
}

// *
// Describes possible filters that can be applied to unused resources
// (see SchedulerDriver::launchTasks) to influence the allocator.
type Filters struct {
	// Time to consider unused resources refused. Note that all unused
	// resources will be considered refused and use the default value
	// (below) regardless of whether Filters was passed to
	// SchedulerDriver::launchTasks. You MUST pass Filters with this
	// field set to change this behavior (i.e., get another offer which
	// includes unused resources sooner or later than the default).
	RefuseSeconds    *float64 `protobuf:"fixed64,1,opt,name=refuse_seconds,def=5" json:"refuse_seconds,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Filters) Reset()                    { *m = Filters{} }
func (m *Filters) String() string            { return proto.CompactTextString(m) }
func (*Filters) ProtoMessage()               {}
func (*Filters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{79} }

const Default_Filters_RefuseSeconds float64 = 5

func (m *Filters) GetRefuseSeconds() float64 {
	if m != nil && m.RefuseSeconds != nil {
		return *m.RefuseSeconds
	}
	return Default_Filters_RefuseSeconds
}

// *
// Describes a collection of environment variables. This is used with
// CommandInfo in order to set environment variables before running a
// command.
type Environment struct {
	Variables        []*Environment_Variable `protobuf:"bytes,1,rep,name=variables" json:"variables,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *Environment) Reset()                    { *m = Environment{} }
func (m *Environment) String() string            { return proto.CompactTextString(m) }
func (*Environment) ProtoMessage()               {}
func (*Environment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{80} }

func (m *Environment) GetVariables() []*Environment_Variable {
	if m != nil {
		return m.Variables
	}
	return nil
}

type Environment_Variable struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Environment_Variable) Reset()                    { *m = Environment_Variable{} }
func (m *Environment_Variable) String() string            { return proto.CompactTextString(m) }
func (*Environment_Variable) ProtoMessage()               {}
func (*Environment_Variable) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{80, 0} }

func (m *Environment_Variable) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Environment_Variable) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A generic (key, value) pair used in various places for parameters.
type Parameter struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{81} }

func (m *Parameter) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Parameter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Collection of Parameter.
type Parameters struct {
	Parameter        []*Parameter `protobuf:"bytes,1,rep,name=parameter" json:"parameter,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Parameters) Reset()                    { *m = Parameters{} }
func (m *Parameters) String() string            { return proto.CompactTextString(m) }
func (*Parameters) ProtoMessage()               {}
func (*Parameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{82} }

func (m *Parameters) GetParameter() []*Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// *
// Credential used in various places for authentication and
// authorization.
//
// NOTE: A 'principal' is different from 'FrameworkInfo.user'. The
// former is used for authentication and authorization while the
// latter is used to determine the default user under which the
// framework's executors/tasks are run.
type Credential struct {
	Principal        *string `protobuf:"bytes,1,req,name=principal" json:"principal,omitempty"`
	Secret           *string `protobuf:"bytes,2,opt,name=secret" json:"secret,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Credential) Reset()                    { *m = Credential{} }
func (m *Credential) String() string            { return proto.CompactTextString(m) }
func (*Credential) ProtoMessage()               {}
func (*Credential) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{83} }

func (m *Credential) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *Credential) GetSecret() string {
	if m != nil && m.Secret != nil {
		return *m.Secret
	}
	return ""
}

// *
// Credentials used for framework authentication, HTTP authentication
// (where the common 'username' and 'password' are captured as
// 'principal' and 'secret' respectively), etc.
type Credentials struct {
	Credentials      []*Credential `protobuf:"bytes,1,rep,name=credentials" json:"credentials,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Credentials) Reset()                    { *m = Credentials{} }
func (m *Credentials) String() string            { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()               {}
func (*Credentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{84} }

func (m *Credentials) GetCredentials() []*Credential {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// *
// Rate (queries per second, QPS) limit for messages from a framework to master.
// Strictly speaking they are the combined rate from all frameworks of the same
// principal.
type RateLimit struct {
	// Leaving QPS unset gives it unlimited rate (i.e., not throttled),
	// which also implies unlimited capacity.
	Qps *float64 `protobuf:"fixed64,1,opt,name=qps" json:"qps,omitempty"`
	// Principal of framework(s) to be throttled. Should match
	// FrameworkInfo.principal and Credential.principal (if using authentication).
	Principal *string `protobuf:"bytes,2,req,name=principal" json:"principal,omitempty"`
	// Max number of outstanding messages from frameworks of this principal
	// allowed by master before the next message is dropped and an error is sent
	// back to the sender. Messages received before the capacity is reached are
	// still going to be processed after the error is sent.
	// If unspecified, this principal is assigned unlimited capacity.
	// NOTE: This value is ignored if 'qps' is not set.
	Capacity         *uint64 `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RateLimit) Reset()                    { *m = RateLimit{} }
func (m *RateLimit) String() string            { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()               {}
func (*RateLimit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{85} }

func (m *RateLimit) GetQps() float64 {
	if m != nil && m.Qps != nil {
		return *m.Qps
	}
	return 0
}

func (m *RateLimit) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *RateLimit) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

// *
// Collection of RateLimit.
// Frameworks without rate limits defined here are not throttled unless
// 'aggregate_default_qps' is specified.
type RateLimits struct {
	// Items should have unique principals.
	Limits []*RateLimit `protobuf:"bytes,1,rep,name=limits" json:"limits,omitempty"`
	// All the frameworks not specified in 'limits' get this default rate.
	// This rate is an aggregate rate for all of them, i.e., their combined
	// traffic is throttled together at this rate.
	AggregateDefaultQps *float64 `protobuf:"fixed64,2,opt,name=aggregate_default_qps" json:"aggregate_default_qps,omitempty"`
	// All the frameworks not specified in 'limits' get this default capacity.
	// This is an aggregate value similar to 'aggregate_default_qps'.
	AggregateDefaultCapacity *uint64 `protobuf:"varint,3,opt,name=aggregate_default_capacity" json:"aggregate_default_capacity,omitempty"`
	XXX_unrecognized         []byte  `json:"-"`
}

func (m *RateLimits) Reset()                    { *m = RateLimits{} }
func (m *RateLimits) String() string            { return proto.CompactTextString(m) }
func (*RateLimits) ProtoMessage()               {}
func (*RateLimits) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{86} }

func (m *RateLimits) GetLimits() []*RateLimit {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *RateLimits) GetAggregateDefaultQps() float64 {
	if m != nil && m.AggregateDefaultQps != nil {
		return *m.AggregateDefaultQps
	}
	return 0
}

func (m *RateLimits) GetAggregateDefaultCapacity() uint64 {
	if m != nil && m.AggregateDefaultCapacity != nil {
		return *m.AggregateDefaultCapacity
	}
	return 0
}

// *
// Describe an image used by tasks or executors. Note that it's only
// for tasks or executors launched by MesosContainerizer currently.
// TODO(jieyu): This feature not fully supported in 0.24.0. Please do
// not use it until this feature is announced.
type Image struct {
	Type *Image_Type `protobuf:"varint,1,req,name=type,enum=Image_Type" json:"type,omitempty"`
	// Only one of the following image messages should be set to match
	// the type.
	Appc             *Image_Appc   `protobuf:"bytes,2,opt,name=appc" json:"appc,omitempty"`
	Docker           *Image_Docker `protobuf:"bytes,3,opt,name=docker" json:"docker,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{87} }

func (m *Image) GetType() Image_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Image_APPC
}

func (m *Image) GetAppc() *Image_Appc {
	if m != nil {
		return m.Appc
	}
	return nil
}

func (m *Image) GetDocker() *Image_Docker {
	if m != nil {
		return m.Docker
	}
	return nil
}

// Protobuf for specifying an Appc container image. See:
// https://github.com/appc/spec/blob/master/spec/aci.md
type Image_Appc struct {
	// The name of the image.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// An image ID is a string of the format "hash-value", where
	// "hash" is the hash algorithm used and "value" is the hex
	// encoded string of the digest. Currently the only permitted
	// hash algorithm is sha512.
	Id *string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Optional labels. Suggested labels: "version", "os", and "arch".
	Labels           *Labels `protobuf:"bytes,3,opt,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Image_Appc) Reset()                    { *m = Image_Appc{} }
func (m *Image_Appc) String() string            { return proto.CompactTextString(m) }
func (*Image_Appc) ProtoMessage()               {}
func (*Image_Appc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{87, 0} }

func (m *Image_Appc) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Image_Appc) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Image_Appc) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Image_Docker struct {
	// The name of the image. Expected format:
	//   [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG|@TYPE:DIGEST]
	//
	// See: https://docs.docker.com/reference/commandline/pull/
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Image_Docker) Reset()                    { *m = Image_Docker{} }
func (m *Image_Docker) String() string            { return proto.CompactTextString(m) }
func (*Image_Docker) ProtoMessage()               {}
func (*Image_Docker) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{87, 1} }

func (m *Image_Docker) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// *
// Describes a volume mapping either from host to container or vice
// versa. Both paths can either refer to a directory or a file.
type Volume struct {
	Mode *Volume_Mode `protobuf:"varint,3,req,name=mode,enum=Volume_Mode" json:"mode,omitempty"`
	// Path pointing to a directory or file in the container. If the
	// path is a relative path, it is relative to the container work
	// directory. If the path is an absolute path, that path must
	// already exist.
	ContainerPath *string `protobuf:"bytes,1,req,name=container_path" json:"container_path,omitempty"`
	// Absolute path pointing to a directory or file on the host or a
	// path relative to the container work directory.
	HostPath *string `protobuf:"bytes,2,opt,name=host_path" json:"host_path,omitempty"`
	// The source of the volume is an Image which describes a root
	// filesystem which will be provisioned by Mesos.
	Image            *Image `protobuf:"bytes,4,opt,name=image" json:"image,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{88} }

func (m *Volume) GetMode() Volume_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Volume_RW
}

func (m *Volume) GetContainerPath() string {
	if m != nil && m.ContainerPath != nil {
		return *m.ContainerPath
	}
	return ""
}

func (m *Volume) GetHostPath() string {
	if m != nil && m.HostPath != nil {
		return *m.HostPath
	}
	return ""
}

func (m *Volume) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

// *
// Describes a network request from a framework as well as network resolution
// provided by Mesos.
//
// A Framework may request the network isolator on the Agent to isolate the
// container in a network namespace and create a virtual network interface.
// The `NetworkInfo` message describes the properties of that virtual
// interface, including the IP addresses and network isolation policy
// (network group membership).
//
// The NetworkInfo message is not interpreted by the Master or Agent and is
// intended to be used by Agent and Master modules implementing network
// isolation. If the modules are missing, the message is simply ignored. In
// future, the task launch will fail if there is no module providing the
// network isolation capabilities (MESOS-3390).
//
// An executor, Agent, or an Agent module may append NetworkInfos inside
// TaskStatus::container_status to provide information such as the container IP
// address and isolation groups.
type NetworkInfo struct {
	// When included in a ContainerInfo, each of these represent a
	// request for an IP address. Each request can specify an explicit address
	// or the IP protocol to use.
	//
	// When included in a TaskStatus message, these inform the framework
	// scheduler about the IP addresses that are bound to the container
	// interface. When there are no custom network isolator modules installed,
	// this field is filled in automatically with the Agent IP address.
	IpAddresses []*NetworkInfo_IPAddress `protobuf:"bytes,5,rep,name=ip_addresses" json:"ip_addresses,omitempty"`
	// Specify IP address requirement. Set protocol to the desired value to
	// request the network isolator on the Agent to assign an IP address to the
	// container being launched. If a specific IP address is specified in
	// ip_address, this field should not be set.
	Protocol *NetworkInfo_Protocol `protobuf:"varint,1,opt,name=protocol,enum=NetworkInfo_Protocol" json:"protocol,omitempty"`
	// Statically assigned IP provided by the Framework. This IP will be assigned
	// to the container by the network isolator module on the Agent. This field
	// should not be used with the protocol field above.
	// NOTE: It is up to the networking 'provider' (IPAM/Isolator) to interpret
	// this either as a hint of as a requirement for assigning the IP.
	IpAddress *string `protobuf:"bytes,2,opt,name=ip_address" json:"ip_address,omitempty"`
	// A group is the name given to a set of logically-related interfaces that
	// are allowed to communicate among themselves. Network traffic is allowed
	// between two container interfaces that share at least one network group.
	// For example, one might want to create separate groups for isolating dev,
	// testing, qa and prod deployment environments.
	Groups []string `protobuf:"bytes,3,rep,name=groups" json:"groups,omitempty"`
	// To tag certain metadata to be used by Isolator/IPAM, e.g., rack, etc.
	Labels           *Labels `protobuf:"bytes,4,opt,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NetworkInfo) Reset()                    { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()               {}
func (*NetworkInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{89} }

func (m *NetworkInfo) GetIpAddresses() []*NetworkInfo_IPAddress {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *NetworkInfo) GetProtocol() NetworkInfo_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return NetworkInfo_IPv4
}

func (m *NetworkInfo) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *NetworkInfo) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *NetworkInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Specifies a request for an IP address, or reports the assigned container
// IP address.
//
// Users can request an automatically assigned IP (for example, via an
// IPAM service) or a specific IP by adding a NetworkInfo to the
// ContainerInfo for a task.  On a request, specifying neither `protocol`
// nor `ip_address` means that any available address may be assigned.
type NetworkInfo_IPAddress struct {
	// Specify IP address requirement. Set protocol to the desired value to
	// request the network isolator on the Agent to assign an IP address to the
	// container being launched. If a specific IP address is specified in
	// ip_address, this field should not be set.
	Protocol *NetworkInfo_Protocol `protobuf:"varint,1,opt,name=protocol,enum=NetworkInfo_Protocol" json:"protocol,omitempty"`
	// Statically assigned IP provided by the Framework. This IP will be
	// assigned to the container by the network isolator module on the Agent.
	// This field should not be used with the protocol field above.
	//
	// If an explicit address is requested but is unavailable, the network
	// isolator should fail the task.
	IpAddress        *string `protobuf:"bytes,2,opt,name=ip_address" json:"ip_address,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NetworkInfo_IPAddress) Reset()                    { *m = NetworkInfo_IPAddress{} }
func (m *NetworkInfo_IPAddress) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfo_IPAddress) ProtoMessage()               {}
func (*NetworkInfo_IPAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{89, 0} }

func (m *NetworkInfo_IPAddress) GetProtocol() NetworkInfo_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return NetworkInfo_IPv4
}

func (m *NetworkInfo_IPAddress) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

// *
// Describes a container configuration and allows extensible
// configurations for different container implementations.
type ContainerInfo struct {
	Type     *ContainerInfo_Type `protobuf:"varint,1,req,name=type,enum=ContainerInfo_Type" json:"type,omitempty"`
	Volumes  []*Volume           `protobuf:"bytes,2,rep,name=volumes" json:"volumes,omitempty"`
	Hostname *string             `protobuf:"bytes,4,opt,name=hostname" json:"hostname,omitempty"`
	// Only one of the following *Info messages should be set to match
	// the type.
	Docker *ContainerInfo_DockerInfo `protobuf:"bytes,3,opt,name=docker" json:"docker,omitempty"`
	Mesos  *ContainerInfo_MesosInfo  `protobuf:"bytes,5,opt,name=mesos" json:"mesos,omitempty"`
	// A list of network requests. A framework can request multiple IP addresses
	// for the container.
	NetworkInfos     []*NetworkInfo `protobuf:"bytes,7,rep,name=network_infos" json:"network_infos,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ContainerInfo) Reset()                    { *m = ContainerInfo{} }
func (m *ContainerInfo) String() string            { return proto.CompactTextString(m) }
func (*ContainerInfo) ProtoMessage()               {}
func (*ContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{90} }

func (m *ContainerInfo) GetType() ContainerInfo_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ContainerInfo_DOCKER
}

func (m *ContainerInfo) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *ContainerInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *ContainerInfo) GetDocker() *ContainerInfo_DockerInfo {
	if m != nil {
		return m.Docker
	}
	return nil
}

func (m *ContainerInfo) GetMesos() *ContainerInfo_MesosInfo {
	if m != nil {
		return m.Mesos
	}
	return nil
}

func (m *ContainerInfo) GetNetworkInfos() []*NetworkInfo {
	if m != nil {
		return m.NetworkInfos
	}
	return nil
}

type ContainerInfo_DockerInfo struct {
	// The docker image that is going to be passed to the registry.
	Image        *string                                 `protobuf:"bytes,1,req,name=image" json:"image,omitempty"`
	Network      *ContainerInfo_DockerInfo_Network       `protobuf:"varint,2,opt,name=network,enum=ContainerInfo_DockerInfo_Network,def=1" json:"network,omitempty"`
	PortMappings []*ContainerInfo_DockerInfo_PortMapping `protobuf:"bytes,3,rep,name=port_mappings" json:"port_mappings,omitempty"`
	Privileged   *bool                                   `protobuf:"varint,4,opt,name=privileged,def=0" json:"privileged,omitempty"`
	// Allowing arbitrary parameters to be passed to docker CLI.
	// Note that anything passed to this field is not guaranteed
	// to be supported moving forward, as we might move away from
	// the docker CLI.
	Parameters []*Parameter `protobuf:"bytes,5,rep,name=parameters" json:"parameters,omitempty"`
	// With this flag set to true, the docker containerizer will
	// pull the docker image from the registry even if the image
	// is already downloaded on the slave.
	ForcePullImage   *bool  `protobuf:"varint,6,opt,name=force_pull_image" json:"force_pull_image,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ContainerInfo_DockerInfo) Reset()                    { *m = ContainerInfo_DockerInfo{} }
func (m *ContainerInfo_DockerInfo) String() string            { return proto.CompactTextString(m) }
func (*ContainerInfo_DockerInfo) ProtoMessage()               {}
func (*ContainerInfo_DockerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{90, 0} }

const Default_ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network = ContainerInfo_DockerInfo_HOST
const Default_ContainerInfo_DockerInfo_Privileged bool = false

func (m *ContainerInfo_DockerInfo) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *ContainerInfo_DockerInfo) GetNetwork() ContainerInfo_DockerInfo_Network {
	if m != nil && m.Network != nil {
		return *m.Network
	}
	return Default_ContainerInfo_DockerInfo_Network
}

func (m *ContainerInfo_DockerInfo) GetPortMappings() []*ContainerInfo_DockerInfo_PortMapping {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

func (m *ContainerInfo_DockerInfo) GetPrivileged() bool {
	if m != nil && m.Privileged != nil {
		return *m.Privileged
	}
	return Default_ContainerInfo_DockerInfo_Privileged
}

func (m *ContainerInfo_DockerInfo) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ContainerInfo_DockerInfo) GetForcePullImage() bool {
	if m != nil && m.ForcePullImage != nil {
		return *m.ForcePullImage
	}
	return false
}

type ContainerInfo_DockerInfo_PortMapping struct {
	HostPort      *uint32 `protobuf:"varint,1,req,name=host_port" json:"host_port,omitempty"`
	ContainerPort *uint32 `protobuf:"varint,2,req,name=container_port" json:"container_port,omitempty"`
	// Protocol to expose as (ie: tcp, udp).
	Protocol         *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContainerInfo_DockerInfo_PortMapping) Reset()         { *m = ContainerInfo_DockerInfo_PortMapping{} }
func (m *ContainerInfo_DockerInfo_PortMapping) String() string { return proto.CompactTextString(m) }
func (*ContainerInfo_DockerInfo_PortMapping) ProtoMessage()    {}
func (*ContainerInfo_DockerInfo_PortMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{90, 0, 0}
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetHostPort() uint32 {
	if m != nil && m.HostPort != nil {
		return *m.HostPort
	}
	return 0
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetContainerPort() uint32 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

type ContainerInfo_MesosInfo struct {
	Image            *Image `protobuf:"bytes,1,opt,name=image" json:"image,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ContainerInfo_MesosInfo) Reset()                    { *m = ContainerInfo_MesosInfo{} }
func (m *ContainerInfo_MesosInfo) String() string            { return proto.CompactTextString(m) }
func (*ContainerInfo_MesosInfo) ProtoMessage()               {}
func (*ContainerInfo_MesosInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{90, 1} }

func (m *ContainerInfo_MesosInfo) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

// *
// Container related information that is resolved during container setup. The
// information is sent back to the framework as part of the TaskStatus message.
type ContainerStatus struct {
	// This field can be reliably used to identify the container IP address.
	NetworkInfos     []*NetworkInfo `protobuf:"bytes,1,rep,name=network_infos" json:"network_infos,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ContainerStatus) Reset()                    { *m = ContainerStatus{} }
func (m *ContainerStatus) String() string            { return proto.CompactTextString(m) }
func (*ContainerStatus) ProtoMessage()               {}
func (*ContainerStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{91} }

func (m *ContainerStatus) GetNetworkInfos() []*NetworkInfo {
	if m != nil {
		return m.NetworkInfos
	}
	return nil
}

// *
// Collection of labels.
type Labels struct {
	Labels           []*Label `protobuf:"bytes,1,rep,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Labels) Reset()                    { *m = Labels{} }
func (m *Labels) String() string            { return proto.CompactTextString(m) }
func (*Labels) ProtoMessage()               {}
func (*Labels) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{92} }

func (m *Labels) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// *
// Key, value pair used to store free form user-data.
type Label struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Label) Reset()                    { *m = Label{} }
func (m *Label) String() string            { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()               {}
func (*Label) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{93} }

func (m *Label) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Named port used for service discovery.
type Port struct {
	Number           *uint32                   `protobuf:"varint,1,req,name=number" json:"number,omitempty"`
	Name             *string                   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Protocol         *string                   `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	Visibility       *DiscoveryInfo_Visibility `protobuf:"varint,4,opt,name=visibility,enum=DiscoveryInfo_Visibility" json:"visibility,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (m *Port) String() string            { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{94} }

func (m *Port) GetNumber() uint32 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

func (m *Port) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Port) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func (m *Port) GetVisibility() DiscoveryInfo_Visibility {
	if m != nil && m.Visibility != nil {
		return *m.Visibility
	}
	return DiscoveryInfo_FRAMEWORK
}

// *
// Collection of ports.
type Ports struct {
	Ports            []*Port `protobuf:"bytes,1,rep,name=ports" json:"ports,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ports) Reset()                    { *m = Ports{} }
func (m *Ports) String() string            { return proto.CompactTextString(m) }
func (*Ports) ProtoMessage()               {}
func (*Ports) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{95} }

func (m *Ports) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

// *
// Service discovery information.
// The visibility field restricts discovery within a framework (FRAMEWORK),
// within a Mesos cluster (CLUSTER), or places no restrictions (EXTERNAL).
// Each port in the ports field also has an optional visibility field.
// If visibility is specified for a port, it overrides the default service-wide
// DiscoveryInfo.visibility for that port.
// The environment, location, and version fields provide first class support for
// common attributes used to differentiate between similar services. The
// environment may receive values such as PROD/QA/DEV, the location field may
// receive values like EAST-US/WEST-US/EUROPE/AMEA, and the version field may
// receive values like v2.0/v0.9. The exact use of these fields is up to each
// service discovery system.
type DiscoveryInfo struct {
	Visibility       *DiscoveryInfo_Visibility `protobuf:"varint,1,req,name=visibility,enum=DiscoveryInfo_Visibility" json:"visibility,omitempty"`
	Name             *string                   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Environment      *string                   `protobuf:"bytes,3,opt,name=environment" json:"environment,omitempty"`
	Location         *string                   `protobuf:"bytes,4,opt,name=location" json:"location,omitempty"`
	Version          *string                   `protobuf:"bytes,5,opt,name=version" json:"version,omitempty"`
	Ports            *Ports                    `protobuf:"bytes,6,opt,name=ports" json:"ports,omitempty"`
	Labels           *Labels                   `protobuf:"bytes,7,opt,name=labels" json:"labels,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *DiscoveryInfo) Reset()                    { *m = DiscoveryInfo{} }
func (m *DiscoveryInfo) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryInfo) ProtoMessage()               {}
func (*DiscoveryInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{96} }

func (m *DiscoveryInfo) GetVisibility() DiscoveryInfo_Visibility {
	if m != nil && m.Visibility != nil {
		return *m.Visibility
	}
	return DiscoveryInfo_FRAMEWORK
}

func (m *DiscoveryInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DiscoveryInfo) GetEnvironment() string {
	if m != nil && m.Environment != nil {
		return *m.Environment
	}
	return ""
}

func (m *DiscoveryInfo) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

func (m *DiscoveryInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *DiscoveryInfo) GetPorts() *Ports {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DiscoveryInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

// *
// Protobuf for the Appc image manifest JSON schema:
// https://github.com/appc/spec/blob/master/spec/aci.md#image-manifest-schema
// Where possible, any field required in the schema is required in the protobuf
// but some cannot be expressed, e.g., a repeated string that has at least one
// element. Further validation should be performed after parsing the JSON into
// the protobuf.
// This version of Appc protobuf is based on Appc spec version 0.6.1.
// TODO(xujyan): This protobuf currently defines a subset of fields in the spec
// that Mesos makes use of to avoid confusion. New fields are going to be added
// when Mesos starts to support them.
type AppcImageManifest struct {
	AcKind           *string                         `protobuf:"bytes,1,req,name=acKind" json:"acKind,omitempty"`
	AcVersion        *string                         `protobuf:"bytes,2,req,name=acVersion" json:"acVersion,omitempty"`
	Name             *string                         `protobuf:"bytes,3,req,name=name" json:"name,omitempty"`
	Labels           []*AppcImageManifest_Label      `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty"`
	Annotations      []*AppcImageManifest_Annotation `protobuf:"bytes,5,rep,name=annotations" json:"annotations,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *AppcImageManifest) Reset()                    { *m = AppcImageManifest{} }
func (m *AppcImageManifest) String() string            { return proto.CompactTextString(m) }
func (*AppcImageManifest) ProtoMessage()               {}
func (*AppcImageManifest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{97} }

func (m *AppcImageManifest) GetAcKind() string {
	if m != nil && m.AcKind != nil {
		return *m.AcKind
	}
	return ""
}

func (m *AppcImageManifest) GetAcVersion() string {
	if m != nil && m.AcVersion != nil {
		return *m.AcVersion
	}
	return ""
}

func (m *AppcImageManifest) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AppcImageManifest) GetLabels() []*AppcImageManifest_Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *AppcImageManifest) GetAnnotations() []*AppcImageManifest_Annotation {
	if m != nil {
		return m.Annotations
	}
	return nil
}

type AppcImageManifest_Label struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AppcImageManifest_Label) Reset()                    { *m = AppcImageManifest_Label{} }
func (m *AppcImageManifest_Label) String() string            { return proto.CompactTextString(m) }
func (*AppcImageManifest_Label) ProtoMessage()               {}
func (*AppcImageManifest_Label) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{97, 0} }

func (m *AppcImageManifest_Label) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AppcImageManifest_Label) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type AppcImageManifest_Annotation struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AppcImageManifest_Annotation) Reset()         { *m = AppcImageManifest_Annotation{} }
func (m *AppcImageManifest_Annotation) String() string { return proto.CompactTextString(m) }
func (*AppcImageManifest_Annotation) ProtoMessage()    {}
func (*AppcImageManifest_Annotation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{97, 1}
}

func (m *AppcImageManifest_Annotation) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AppcImageManifest_Annotation) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*Task)(nil), "Task")
	proto.RegisterType((*StatusUpdate)(nil), "StatusUpdate")
	proto.RegisterType((*StatusUpdateRecord)(nil), "StatusUpdateRecord")
	proto.RegisterType((*SubmitSchedulerRequest)(nil), "SubmitSchedulerRequest")
	proto.RegisterType((*SubmitSchedulerResponse)(nil), "SubmitSchedulerResponse")
	proto.RegisterType((*ExecutorToFrameworkMessage)(nil), "ExecutorToFrameworkMessage")
	proto.RegisterType((*FrameworkToExecutorMessage)(nil), "FrameworkToExecutorMessage")
	proto.RegisterType((*RegisterFrameworkMessage)(nil), "RegisterFrameworkMessage")
	proto.RegisterType((*ReregisterFrameworkMessage)(nil), "ReregisterFrameworkMessage")
	proto.RegisterType((*FrameworkRegisteredMessage)(nil), "FrameworkRegisteredMessage")
	proto.RegisterType((*FrameworkReregisteredMessage)(nil), "FrameworkReregisteredMessage")
	proto.RegisterType((*UnregisterFrameworkMessage)(nil), "UnregisterFrameworkMessage")
	proto.RegisterType((*DeactivateFrameworkMessage)(nil), "DeactivateFrameworkMessage")
	proto.RegisterType((*ResourceRequestMessage)(nil), "ResourceRequestMessage")
	proto.RegisterType((*ResourceOffersMessage)(nil), "ResourceOffersMessage")
	proto.RegisterType((*LaunchTasksMessage)(nil), "LaunchTasksMessage")
	proto.RegisterType((*RescindResourceOfferMessage)(nil), "RescindResourceOfferMessage")
	proto.RegisterType((*ReviveOffersMessage)(nil), "ReviveOffersMessage")
	proto.RegisterType((*RunTaskMessage)(nil), "RunTaskMessage")
	proto.RegisterType((*KillTaskMessage)(nil), "KillTaskMessage")
	proto.RegisterType((*StatusUpdateMessage)(nil), "StatusUpdateMessage")
	proto.RegisterType((*StatusUpdateAcknowledgementMessage)(nil), "StatusUpdateAcknowledgementMessage")
	proto.RegisterType((*LostSlaveMessage)(nil), "LostSlaveMessage")
	proto.RegisterType((*ReconcileTasksMessage)(nil), "ReconcileTasksMessage")
	proto.RegisterType((*FrameworkErrorMessage)(nil), "FrameworkErrorMessage")
	proto.RegisterType((*RegisterSlaveMessage)(nil), "RegisterSlaveMessage")
	proto.RegisterType((*ReregisterSlaveMessage)(nil), "ReregisterSlaveMessage")
	proto.RegisterType((*SlaveRegisteredMessage)(nil), "SlaveRegisteredMessage")
	proto.RegisterType((*SlaveReregisteredMessage)(nil), "SlaveReregisteredMessage")
	proto.RegisterType((*UnregisterSlaveMessage)(nil), "UnregisterSlaveMessage")
	proto.RegisterType((*MasterSlaveConnection)(nil), "MasterSlaveConnection")
	proto.RegisterType((*PingSlaveMessage)(nil), "PingSlaveMessage")
	proto.RegisterType((*PongSlaveMessage)(nil), "PongSlaveMessage")
	proto.RegisterType((*ShutdownFrameworkMessage)(nil), "ShutdownFrameworkMessage")
	proto.RegisterType((*ShutdownExecutorMessage)(nil), "ShutdownExecutorMessage")
	proto.RegisterType((*UpdateFrameworkMessage)(nil), "UpdateFrameworkMessage")
	proto.RegisterType((*CheckpointResourcesMessage)(nil), "CheckpointResourcesMessage")
	proto.RegisterType((*UpdateSlaveMessage)(nil), "UpdateSlaveMessage")
	proto.RegisterType((*RegisterExecutorMessage)(nil), "RegisterExecutorMessage")
	proto.RegisterType((*ExecutorRegisteredMessage)(nil), "ExecutorRegisteredMessage")
	proto.RegisterType((*ExecutorReregisteredMessage)(nil), "ExecutorReregisteredMessage")
	proto.RegisterType((*ExitedExecutorMessage)(nil), "ExitedExecutorMessage")
	proto.RegisterType((*ReconnectExecutorMessage)(nil), "ReconnectExecutorMessage")
	proto.RegisterType((*ReregisterExecutorMessage)(nil), "ReregisterExecutorMessage")
	proto.RegisterType((*ShutdownMessage)(nil), "ShutdownMessage")
	proto.RegisterType((*Archive)(nil), "Archive")
	proto.RegisterType((*Archive_Framework)(nil), "Archive.Framework")
	proto.RegisterType((*TaskHealthStatus)(nil), "TaskHealthStatus")
	proto.RegisterType((*HookExecuted)(nil), "HookExecuted")
	proto.RegisterType((*FrameworkID)(nil), "FrameworkID")
	proto.RegisterType((*OfferID)(nil), "OfferID")
	proto.RegisterType((*SlaveID)(nil), "SlaveID")
	proto.RegisterType((*TaskID)(nil), "TaskID")
	proto.RegisterType((*ExecutorID)(nil), "ExecutorID")
	proto.RegisterType((*ContainerID)(nil), "ContainerID")
	proto.RegisterType((*TimeInfo)(nil), "TimeInfo")
	proto.RegisterType((*DurationInfo)(nil), "DurationInfo")
	proto.RegisterType((*Address)(nil), "Address")
	proto.RegisterType((*URL)(nil), "URL")
	proto.RegisterType((*Unavailability)(nil), "Unavailability")
	proto.RegisterType((*MachineID)(nil), "MachineID")
	proto.RegisterType((*MachineInfo)(nil), "MachineInfo")
	proto.RegisterType((*FrameworkInfo)(nil), "FrameworkInfo")
	proto.RegisterType((*FrameworkInfo_Capability)(nil), "FrameworkInfo.Capability")
	proto.RegisterType((*HealthCheck)(nil), "HealthCheck")
	proto.RegisterType((*HealthCheck_HTTP)(nil), "HealthCheck.HTTP")
	proto.RegisterType((*CommandInfo)(nil), "CommandInfo")
	proto.RegisterType((*CommandInfo_URI)(nil), "CommandInfo.URI")
	proto.RegisterType((*CommandInfo_ContainerInfo)(nil), "CommandInfo.ContainerInfo")
	proto.RegisterType((*ExecutorInfo)(nil), "ExecutorInfo")
	proto.RegisterType((*MasterInfo)(nil), "MasterInfo")
	proto.RegisterType((*SlaveInfo)(nil), "SlaveInfo")
	proto.RegisterType((*Value)(nil), "Value")
	proto.RegisterType((*Value_Scalar)(nil), "Value.Scalar")
	proto.RegisterType((*Value_Range)(nil), "Value.Range")
	proto.RegisterType((*Value_Ranges)(nil), "Value.Ranges")
	proto.RegisterType((*Value_Set)(nil), "Value.Set")
	proto.RegisterType((*Value_Text)(nil), "Value.Text")
	proto.RegisterType((*Attribute)(nil), "Attribute")
	proto.RegisterType((*Resource)(nil), "Resource")
	proto.RegisterType((*Resource_ReservationInfo)(nil), "Resource.ReservationInfo")
	proto.RegisterType((*Resource_DiskInfo)(nil), "Resource.DiskInfo")
	proto.RegisterType((*Resource_DiskInfo_Persistence)(nil), "Resource.DiskInfo.Persistence")
	proto.RegisterType((*Resource_RevocableInfo)(nil), "Resource.RevocableInfo")
	proto.RegisterType((*TrafficControlStatistics)(nil), "TrafficControlStatistics")
	proto.RegisterType((*ResourceStatistics)(nil), "ResourceStatistics")
	proto.RegisterType((*ResourceUsage)(nil), "ResourceUsage")
	proto.RegisterType((*ResourceUsage_Executor)(nil), "ResourceUsage.Executor")
	proto.RegisterType((*PerfStatistics)(nil), "PerfStatistics")
	proto.RegisterType((*Request)(nil), "Request")
	proto.RegisterType((*Offer)(nil), "Offer")
	proto.RegisterType((*Offer_Operation)(nil), "Offer.Operation")
	proto.RegisterType((*Offer_Operation_Launch)(nil), "Offer.Operation.Launch")
	proto.RegisterType((*Offer_Operation_Reserve)(nil), "Offer.Operation.Reserve")
	proto.RegisterType((*Offer_Operation_Unreserve)(nil), "Offer.Operation.Unreserve")
	proto.RegisterType((*Offer_Operation_Create)(nil), "Offer.Operation.Create")
	proto.RegisterType((*Offer_Operation_Destroy)(nil), "Offer.Operation.Destroy")
	proto.RegisterType((*InverseOffer)(nil), "InverseOffer")
	proto.RegisterType((*TaskInfo)(nil), "TaskInfo")
	proto.RegisterType((*TaskStatus)(nil), "TaskStatus")
	proto.RegisterType((*Filters)(nil), "Filters")
	proto.RegisterType((*Environment)(nil), "Environment")
	proto.RegisterType((*Environment_Variable)(nil), "Environment.Variable")
	proto.RegisterType((*Parameter)(nil), "Parameter")
	proto.RegisterType((*Parameters)(nil), "Parameters")
	proto.RegisterType((*Credential)(nil), "Credential")
	proto.RegisterType((*Credentials)(nil), "Credentials")
	proto.RegisterType((*RateLimit)(nil), "RateLimit")
	proto.RegisterType((*RateLimits)(nil), "RateLimits")
	proto.RegisterType((*Image)(nil), "Image")
	proto.RegisterType((*Image_Appc)(nil), "Image.Appc")
	proto.RegisterType((*Image_Docker)(nil), "Image.Docker")
	proto.RegisterType((*Volume)(nil), "Volume")
	proto.RegisterType((*NetworkInfo)(nil), "NetworkInfo")
	proto.RegisterType((*NetworkInfo_IPAddress)(nil), "NetworkInfo.IPAddress")
	proto.RegisterType((*ContainerInfo)(nil), "ContainerInfo")
	proto.RegisterType((*ContainerInfo_DockerInfo)(nil), "ContainerInfo.DockerInfo")
	proto.RegisterType((*ContainerInfo_DockerInfo_PortMapping)(nil), "ContainerInfo.DockerInfo.PortMapping")
	proto.RegisterType((*ContainerInfo_MesosInfo)(nil), "ContainerInfo.MesosInfo")
	proto.RegisterType((*ContainerStatus)(nil), "ContainerStatus")
	proto.RegisterType((*Labels)(nil), "Labels")
	proto.RegisterType((*Label)(nil), "Label")
	proto.RegisterType((*Port)(nil), "Port")
	proto.RegisterType((*Ports)(nil), "Ports")
	proto.RegisterType((*DiscoveryInfo)(nil), "DiscoveryInfo")
	proto.RegisterType((*AppcImageManifest)(nil), "AppcImageManifest")
	proto.RegisterType((*AppcImageManifest_Label)(nil), "AppcImageManifest.Label")
	proto.RegisterType((*AppcImageManifest_Annotation)(nil), "AppcImageManifest.Annotation")
	proto.RegisterEnum("Status", Status_name, Status_value)
	proto.RegisterEnum("TaskState", TaskState_name, TaskState_value)
	proto.RegisterEnum("StatusUpdateRecord_Type", StatusUpdateRecord_Type_name, StatusUpdateRecord_Type_value)
	proto.RegisterEnum("MachineInfo_Mode", MachineInfo_Mode_name, MachineInfo_Mode_value)
	proto.RegisterEnum("FrameworkInfo_Capability_Type", FrameworkInfo_Capability_Type_name, FrameworkInfo_Capability_Type_value)
	proto.RegisterEnum("Value_Type", Value_Type_name, Value_Type_value)
	proto.RegisterEnum("Offer_Operation_Type", Offer_Operation_Type_name, Offer_Operation_Type_value)
	proto.RegisterEnum("TaskStatus_Source", TaskStatus_Source_name, TaskStatus_Source_value)
	proto.RegisterEnum("TaskStatus_Reason", TaskStatus_Reason_name, TaskStatus_Reason_value)
	proto.RegisterEnum("Image_Type", Image_Type_name, Image_Type_value)
	proto.RegisterEnum("Volume_Mode", Volume_Mode_name, Volume_Mode_value)
	proto.RegisterEnum("NetworkInfo_Protocol", NetworkInfo_Protocol_name, NetworkInfo_Protocol_value)
	proto.RegisterEnum("ContainerInfo_Type", ContainerInfo_Type_name, ContainerInfo_Type_value)
	proto.RegisterEnum("ContainerInfo_DockerInfo_Network", ContainerInfo_DockerInfo_Network_name, ContainerInfo_DockerInfo_Network_value)
	proto.RegisterEnum("DiscoveryInfo_Visibility", DiscoveryInfo_Visibility_name, DiscoveryInfo_Visibility_value)
}

func init() { proto.RegisterFile("messages.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 5681 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xc4, 0x7b, 0xcd, 0x73, 0x23, 0x59,
	0x52, 0xf8, 0x96, 0xbe, 0x95, 0x92, 0x6d, 0xb5, 0xdc, 0x76, 0xcb, 0x72, 0x7f, 0x56, 0x7f, 0xf7,
	0xcc, 0xaa, 0x7b, 0x7a, 0xa6, 0xe7, 0xf7, 0x9b, 0x86, 0x25, 0x50, 0xdb, 0xea, 0x6e, 0xd1, 0xb6,
	0x64, 0x64, 0xb9, 0x67, 0x66, 0x81, 0xd0, 0x96, 0xa5, 0xb2, 0x5d, 0x58, 0x52, 0x69, 0xaa, 0x4a,
	0xee, 0xf1, 0x85, 0x08, 0x62, 0x23, 0x88, 0x80, 0xd8, 0xdb, 0x46, 0x40, 0x04, 0x7b, 0x00, 0x2e,
	0x44, 0xc0, 0x89, 0x3f, 0x00, 0xb8, 0xcd, 0x81, 0x03, 0x11, 0x1c, 0x39, 0xc1, 0x3f, 0x00, 0xa7,
	0xbd, 0x72, 0x20, 0x33, 0xdf, 0x7b, 0xf5, 0x25, 0xd9, 0xed, 0x9e, 0x80, 0xe5, 0x64, 0x2b, 0x33,
	0x5f, 0xbe, 0x7c, 0x99, 0x2f, 0xbf, 0xde, 0x7b, 0x05, 0x8b, 0x23, 0xd3, 0x75, 0x8d, 0x43, 0xd3,
	0xad, 0x4d, 0x1c, 0xdb, 0xb3, 0xf5, 0x9f, 0x25, 0x21, 0xd5, 0x35, 0xdc, 0xe3, 0x72, 0x11, 0x52,
	0x63, 0x63, 0x64, 0x56, 0xb4, 0x9b, 0x89, 0x07, 0xf9, 0x72, 0x05, 0xb2, 0x1e, 0x42, 0x7b, 0xd6,
	0xa0, 0x92, 0x40, 0x40, 0xe1, 0x69, 0xb6, 0x46, 0x54, 0xcd, 0xcd, 0xb2, 0x0e, 0xc5, 0x03, 0x07,
	0x09, 0xdf, 0xd9, 0x0e, 0xa3, 0x93, 0x8c, 0x2e, 0xd6, 0x5e, 0x2a, 0x20, 0xd2, 0xdc, 0x84, 0x82,
	0xf9, 0xad, 0xd9, 0x9f, 0x7a, 0xb6, 0x43, 0x24, 0xa9, 0x9b, 0x1a, 0x92, 0x14, 0x6a, 0x0d, 0x09,
	0x43, 0x8a, 0x2a, 0xe4, 0xdc, 0xa1, 0x71, 0x62, 0x12, 0x3a, 0xcd, 0x1c, 0x72, 0xb5, 0x5d, 0x02,
	0x20, 0x6e, 0x0d, 0xd2, 0xae, 0x67, 0x78, 0x66, 0x25, 0x83, 0x88, 0xc5, 0xa7, 0xc0, 0x33, 0xef,
	0x12, 0xa4, 0x7c, 0x15, 0xf2, 0x8e, 0xe9, 0xda, 0x53, 0xa7, 0x6f, 0xba, 0x95, 0xec, 0xcd, 0x24,
	0x8e, 0xcb, 0xd7, 0x3a, 0x12, 0x52, 0xbe, 0x86, 0x4c, 0x91, 0x6c, 0xea, 0x22, 0x32, 0xc7, 0xc8,
	0x82, 0x3f, 0x76, 0xea, 0x96, 0xef, 0xc3, 0xb2, 0x40, 0xf7, 0xa6, 0x93, 0x01, 0x72, 0xeb, 0x89,
	0x59, 0xf2, 0x28, 0x5d, 0x74, 0x96, 0x2a, 0x94, 0xa3, 0x84, 0xd3, 0x29, 0x8a, 0x09, 0x48, 0x57,
	0x2c, 0x5f, 0x81, 0xcc, 0xd0, 0xd8, 0x37, 0x87, 0x6e, 0xa5, 0xc0, 0xab, 0xca, 0xd6, 0xb6, 0xf8,
	0x67, 0xf9, 0x16, 0xe4, 0x07, 0x96, 0xdb, 0xb7, 0x4f, 0x4c, 0xe7, 0xb4, 0x52, 0x64, 0xdc, 0x62,
	0x6d, 0x53, 0x41, 0x9a, 0xe3, 0x03, 0x9b, 0x48, 0xfa, 0xf6, 0xd8, 0x33, 0xac, 0xb1, 0xe9, 0x54,
	0x16, 0x24, 0xc9, 0x86, 0x82, 0x10, 0x89, 0xfe, 0x2f, 0x1a, 0x14, 0x85, 0xb8, 0x7b, 0x3c, 0xf5,
	0x8c, 0xba, 0xb5, 0xf7, 0xab, 0x3b, 0x71, 0xbe, 0xba, 0x93, 0x8c, 0x0e, 0xd4, 0xbd, 0x0e, 0x19,
	0xb1, 0x5a, 0xb4, 0x53, 0x22, 0xae, 0xb3, 0x4b, 0x90, 0xf7, 0x2c, 0xdc, 0x32, 0x9e, 0x31, 0x9a,
	0xb0, 0xa1, 0x34, 0xda, 0x28, 0xac, 0x8f, 0x0c, 0xeb, 0xe3, 0x26, 0x14, 0x87, 0x28, 0xa7, 0xeb,
	0x49, 0x6d, 0x66, 0xe3, 0xda, 0xd4, 0xff, 0x48, 0x83, 0x72, 0x78, 0x49, 0x1d, 0xb3, 0x6f, 0x3b,
	0x83, 0xf2, 0x3d, 0x48, 0x79, 0xa7, 0x13, 0xb1, 0xdf, 0x16, 0x9f, 0x56, 0x6a, 0xb3, 0x24, 0xb5,
	0x2e, 0xe2, 0xd1, 0xa8, 0x19, 0x61, 0x05, 0xb9, 0xae, 0x85, 0x08, 0xa5, 0x2f, 0x0d, 0xad, 0xaa,
	0xa8, 0xaf, 0xe3, 0x66, 0xa6, 0x41, 0x00, 0x99, 0xbd, 0x9d, 0xcd, 0x7a, 0xb7, 0x51, 0xfa, 0x41,
	0x39, 0x0b, 0xc9, 0xfa, 0xc6, 0x9b, 0x92, 0xa6, 0xdf, 0x83, 0xd5, 0xdd, 0xe9, 0xfe, 0xc8, 0xf2,
	0x76, 0xfb, 0x47, 0xe6, 0x60, 0x3a, 0x34, 0x9d, 0x8e, 0xf9, 0xcd, 0x14, 0x45, 0x8f, 0xee, 0x7d,
	0xfd, 0x3e, 0x5c, 0x99, 0xa1, 0x73, 0x27, 0xf6, 0xd8, 0xe5, 0xd9, 0xec, 0x63, 0xe3, 0x94, 0x09,
	0x73, 0xfa, 0xcf, 0x34, 0xa8, 0x2a, 0x25, 0x77, 0x6d, 0xdf, 0x22, 0xdb, 0xc2, 0xc3, 0x22, 0x4a,
	0xd7, 0x62, 0x7b, 0x3c, 0x6e, 0xd6, 0xc4, 0xfb, 0xcd, 0x9a, 0x94, 0xd6, 0x09, 0x99, 0x15, 0xc5,
	0x41, 0x25, 0x18, 0x6c, 0xb8, 0x22, 0x8b, 0xe3, 0x8f, 0xef, 0xda, 0x8a, 0xee, 0xff, 0x4a, 0x9c,
	0x1f, 0x41, 0xa5, 0x63, 0x1e, 0x5a, 0xae, 0x67, 0x3a, 0x33, 0xaa, 0x41, 0x4f, 0xf0, 0xe7, 0x93,
	0xc2, 0x2c, 0x86, 0x26, 0x23, 0x4f, 0xf8, 0x6d, 0xa8, 0x76, 0x4c, 0xe7, 0x42, 0x0c, 0x12, 0xf3,
	0x18, 0x94, 0x4b, 0x90, 0x3b, 0x30, 0xac, 0x21, 0xb9, 0x1f, 0x0b, 0x9b, 0xd3, 0xf7, 0x43, 0xfa,
	0x51, 0xa2, 0x99, 0x03, 0xc5, 0xf2, 0x82, 0x9e, 0x36, 0x32, 0x68, 0x58, 0xcf, 0xc2, 0x29, 0xe4,
	0xc4, 0x85, 0xda, 0x36, 0xc3, 0x58, 0xec, 0x01, 0x5c, 0x0d, 0xcd, 0xe1, 0xfc, 0x2f, 0xcd, 0xf2,
	0x9b, 0x50, 0xdd, 0x1b, 0x9f, 0xa9, 0x9c, 0x0b, 0xcc, 0x41, 0x1c, 0x36, 0x4d, 0xa3, 0xef, 0x59,
	0x27, 0xe8, 0x45, 0xdf, 0x8b, 0xc3, 0x57, 0xb0, 0xaa, 0x22, 0xaf, 0xf4, 0xa3, 0x0f, 0x59, 0x23,
	0xee, 0x46, 0x47, 0x8c, 0x72, 0x71, 0x81, 0x49, 0xde, 0x8d, 0x92, 0x0d, 0xea, 0x70, 0x45, 0x71,
	0x6e, 0x1f, 0x1c, 0x98, 0x8e, 0xab, 0x18, 0xaf, 0x42, 0xc6, 0x66, 0x00, 0xb2, 0xa4, 0x21, 0x99,
	0x1a, 0xe3, 0x69, 0xe3, 0x4d, 0xac, 0x81, 0x60, 0x94, 0x2f, 0xdf, 0x85, 0x45, 0x6b, 0x8c, 0x56,
	0x77, 0xcd, 0x9e, 0xa4, 0x4e, 0x32, 0xf5, 0x42, 0xad, 0x29, 0xc0, 0x3c, 0x48, 0xff, 0x13, 0x8c,
	0x4b, 0x5b, 0xc6, 0x74, 0xdc, 0x3f, 0xa2, 0x58, 0xe5, 0x7e, 0x88, 0xf0, 0x15, 0x48, 0x53, 0x76,
	0x54, 0x8c, 0xf3, 0x22, 0x37, 0xd2, 0xa6, 0x5b, 0x83, 0xec, 0x81, 0x35, 0xf4, 0x68, 0x52, 0x95,
	0xd6, 0x5e, 0x8a, 0xdf, 0x18, 0x67, 0xf3, 0x2c, 0x4e, 0x8f, 0x24, 0xcd, 0xc8, 0x25, 0xb3, 0x28,
	0xa8, 0xcc, 0x2f, 0x60, 0x1d, 0x97, 0xdc, 0xb7, 0xc6, 0x83, 0xc8, 0xca, 0x43, 0xbe, 0xab, 0xc6,
	0xfa, 0xbe, 0x1b, 0x0c, 0x5d, 0xee, 0x98, 0x27, 0xd6, 0x49, 0x4c, 0x57, 0x17, 0x31, 0xe1, 0x1f,
	0x6a, 0xb0, 0xd8, 0x99, 0x8e, 0x49, 0x7a, 0x35, 0xec, 0xde, 0xcc, 0x30, 0x2d, 0x3e, 0xec, 0x45,
	0xa2, 0xa2, 0x5d, 0xc4, 0x01, 0xaf, 0x60, 0x84, 0x47, 0xce, 0x32, 0xad, 0x84, 0x94, 0x54, 0x80,
	0xe4, 0x44, 0x86, 0xec, 0xbc, 0xde, 0x86, 0xa5, 0x37, 0xd6, 0x70, 0x18, 0x96, 0xe1, 0x62, 0x26,
	0x38, 0xa3, 0x40, 0xd1, 0xeb, 0xb0, 0x1c, 0xce, 0x10, 0x8a, 0x69, 0x90, 0x47, 0x04, 0xbb, 0x58,
	0x1e, 0x91, 0x32, 0x25, 0x58, 0x26, 0x8c, 0xa4, 0x7a, 0x18, 0x5b, 0xef, 0x1f, 0x8f, 0xed, 0x77,
	0x43, 0x73, 0x70, 0x68, 0x8e, 0xcc, 0xb1, 0xf7, 0x3f, 0x15, 0x51, 0x43, 0x6b, 0x48, 0x46, 0x8b,
	0x2c, 0x95, 0xd5, 0x44, 0x24, 0xad, 0x41, 0x69, 0xcb, 0x76, 0x3d, 0x66, 0x7d, 0x81, 0xb9, 0xf5,
	0x1f, 0x93, 0xff, 0x60, 0xa5, 0xd1, 0xb7, 0x86, 0xe6, 0x07, 0xef, 0xed, 0x70, 0x11, 0x95, 0x98,
	0x29, 0xa2, 0xf4, 0x07, 0xb0, 0xe2, 0x53, 0x37, 0x1c, 0x27, 0x48, 0x2f, 0x4b, 0x90, 0x95, 0xa5,
	0x25, 0xaf, 0x35, 0xaf, 0x8f, 0xe0, 0xb2, 0x0a, 0xb2, 0x11, 0xc9, 0xa9, 0xbc, 0xa3, 0xdf, 0x72,
	0x76, 0x90, 0x62, 0xd3, 0xc6, 0x78, 0x08, 0xab, 0x98, 0x72, 0xfb, 0xc7, 0x13, 0xdb, 0x1a, 0x7b,
	0xe6, 0xa0, 0x17, 0xd4, 0x7a, 0xc9, 0x78, 0xad, 0x87, 0xd3, 0x91, 0x2f, 0x5b, 0xf6, 0x58, 0xda,
	0xec, 0xdf, 0x34, 0x8a, 0x47, 0xce, 0xb9, 0x33, 0x26, 0x3e, 0x60, 0xc6, 0x99, 0xea, 0x12, 0xc3,
	0x4a, 0x90, 0xff, 0x70, 0x2c, 0xd5, 0x4b, 0x22, 0xac, 0xf8, 0x29, 0x90, 0x38, 0x5e, 0x8e, 0xc6,
	0x86, 0x34, 0x2b, 0xaf, 0xfc, 0x04, 0x2e, 0xf7, 0xed, 0xd1, 0x64, 0x68, 0xd2, 0x24, 0xbe, 0x0d,
	0x28, 0x48, 0x10, 0x51, 0xb9, 0x56, 0x77, 0xfa, 0x47, 0xe8, 0xc2, 0x81, 0x25, 0xc2, 0x0b, 0xcc,
	0xf0, 0x02, 0x7f, 0x82, 0xe5, 0x0b, 0xc9, 0x3d, 0x9b, 0xb9, 0xce, 0xdb, 0x87, 0x8f, 0x00, 0x70,
	0x27, 0x8c, 0x4d, 0x8c, 0xf4, 0x52, 0x55, 0x85, 0xa7, 0xab, 0x32, 0x95, 0x30, 0xcd, 0x86, 0x8f,
	0xd5, 0x7f, 0xae, 0x41, 0x45, 0x4e, 0xe1, 0x7c, 0xd0, 0x24, 0x8f, 0x61, 0xc9, 0x91, 0x1b, 0xce,
	0x32, 0x88, 0x95, 0xda, 0x3a, 0xab, 0xb5, 0xf9, 0x1b, 0x31, 0x2a, 0x55, 0xf2, 0x5c, 0xa9, 0x3e,
	0x83, 0xd5, 0x20, 0xd7, 0x5d, 0xd8, 0x07, 0x7e, 0x0d, 0x56, 0xe6, 0xb2, 0x43, 0x1f, 0xa8, 0x7a,
	0xb6, 0x67, 0x0c, 0x7b, 0x13, 0x6b, 0x7c, 0xd8, 0xa3, 0xe2, 0xd6, 0x9e, 0x62, 0xf1, 0x4a, 0x62,
	0x0e, 0x5c, 0x0e, 0x77, 0x9a, 0x7e, 0x17, 0x4a, 0x3b, 0x88, 0x8d, 0x4c, 0x76, 0x89, 0x8b, 0x77,
	0xe2, 0x62, 0x0e, 0x64, 0xfd, 0x57, 0x46, 0x32, 0x3b, 0x4a, 0xa6, 0xff, 0x06, 0xaa, 0xf0, 0x68,
	0xea, 0x0d, 0xec, 0x77, 0xe3, 0xef, 0x95, 0x55, 0x7b, 0x58, 0x7c, 0xca, 0xf1, 0xf1, 0x02, 0x2e,
	0x56, 0x80, 0x69, 0xb3, 0x65, 0xfe, 0x6c, 0xd0, 0x99, 0x09, 0xde, 0x7a, 0x13, 0xd5, 0xc9, 0x41,
	0xed, 0xfb, 0x88, 0x17, 0x0d, 0x93, 0xcf, 0xa1, 0xba, 0xe1, 0x3b, 0x8f, 0xf2, 0x13, 0xdf, 0xc6,
	0x91, 0x5e, 0x4d, 0x8b, 0x79, 0x93, 0xfe, 0x7b, 0x50, 0x16, 0x62, 0x5c, 0xd4, 0xa2, 0xe5, 0x8f,
	0xa0, 0x42, 0xb5, 0x9c, 0x3b, 0xdd, 0x77, 0xfb, 0x8e, 0xb5, 0x1f, 0x71, 0xd6, 0x44, 0x9c, 0x3d,
	0xaa, 0x51, 0xf9, 0x49, 0x5c, 0x8d, 0xdf, 0xab, 0xa3, 0x8a, 0xd7, 0xba, 0xfa, 0x3f, 0x69, 0xb0,
	0xa6, 0x7e, 0xce, 0x7a, 0xe4, 0x1d, 0x58, 0x88, 0xc4, 0x0a, 0xc9, 0x21, 0x16, 0x2a, 0x2e, 0xd2,
	0x4a, 0xdf, 0x83, 0xc5, 0x10, 0x0d, 0xb1, 0x4a, 0xcd, 0x4d, 0xb6, 0xe7, 0x35, 0xd4, 0xd7, 0x01,
	0x24, 0x8e, 0xc6, 0x67, 0xe2, 0x41, 0x50, 0xff, 0x1a, 0xd6, 0x83, 0xa5, 0x7c, 0x98, 0xe7, 0x47,
	0x59, 0xcf, 0xc4, 0x57, 0xfd, 0x8f, 0x35, 0x58, 0x69, 0x7c, 0x6b, 0xa1, 0xcf, 0xfc, 0xea, 0xdb,
	0x91, 0xc5, 0x48, 0x63, 0x9b, 0xd6, 0x3f, 0xa7, 0x86, 0x44, 0xfa, 0xf0, 0x07, 0x48, 0xa3, 0xff,
	0x02, 0x4d, 0x1d, 0xe8, 0xe5, 0xbd, 0x5e, 0x99, 0x78, 0xbf, 0x57, 0x7e, 0x48, 0x45, 0x79, 0x1d,
	0xb2, 0xa2, 0x6e, 0x09, 0xf2, 0x4d, 0xb8, 0x34, 0xd1, 0x75, 0x58, 0x52, 0x01, 0x63, 0x4e, 0x2a,
	0xd6, 0xd8, 0x51, 0xd1, 0x0a, 0x59, 0x99, 0x61, 0x70, 0x43, 0x41, 0x28, 0xff, 0x68, 0x67, 0xe5,
	0x9f, 0xea, 0x5b, 0xc8, 0x07, 0xc9, 0x68, 0x76, 0x17, 0xce, 0x6d, 0xda, 0x22, 0xe1, 0x61, 0x7e,
	0x26, 0xd4, 0xa7, 0x50, 0xa2, 0xbf, 0xaf, 0x4d, 0x63, 0xe8, 0x1d, 0xc9, 0x53, 0x86, 0x50, 0x21,
	0xa4, 0x45, 0x0b, 0x21, 0x5c, 0xca, 0x11, 0x53, 0x9e, 0xb2, 0xda, 0x72, 0x48, 0x9a, 0x3f, 0xc6,
	0x72, 0xb1, 0xc7, 0x95, 0x25, 0x25, 0x8e, 0xdc, 0xf3, 0xf4, 0x81, 0x31, 0x74, 0x29, 0xde, 0x60,
	0x8a, 0xc5, 0x26, 0x1d, 0xd5, 0x8e, 0x2b, 0xe9, 0x51, 0xef, 0x37, 0x75, 0x58, 0x6b, 0x1a, 0x1a,
	0xff, 0x3a, 0x14, 0x5f, 0xdb, 0xf6, 0xb1, 0x30, 0x8b, 0x39, 0xa0, 0xcd, 0x31, 0xb2, 0xa9, 0xb9,
	0x97, 0x2a, 0xba, 0x0a, 0x85, 0xb0, 0x3d, 0x16, 0x20, 0x7d, 0x62, 0x0c, 0xa7, 0xea, 0x48, 0x00,
	0x05, 0x94, 0xe5, 0xf6, 0x1c, 0x8c, 0xda, 0xb5, 0x31, 0xcc, 0x15, 0xc8, 0xc8, 0x45, 0xc4, 0x10,
	0xeb, 0x00, 0xa1, 0xdd, 0x11, 0x43, 0xa2, 0x1c, 0xc1, 0x89, 0xd0, 0x0c, 0xf6, 0x06, 0xe4, 0xba,
	0x98, 0xb1, 0x58, 0xd7, 0xcb, 0x50, 0x18, 0x1b, 0x63, 0x3b, 0xc8, 0x5c, 0x89, 0x07, 0x49, 0xfd,
	0x36, 0x14, 0x37, 0xa7, 0x0e, 0xe7, 0xe0, 0xb3, 0x89, 0x9e, 0xe1, 0x6e, 0x18, 0x0c, 0x50, 0x37,
	0x2e, 0x35, 0xc9, 0x47, 0x58, 0x5a, 0xca, 0xd3, 0x0f, 0xb2, 0x1a, 0x40, 0xc2, 0x9a, 0x48, 0x0b,
	0x52, 0x5f, 0x65, 0x3b, 0x1e, 0x3b, 0x57, 0x5a, 0x3f, 0x86, 0xe4, 0x5e, 0x67, 0x8b, 0xdd, 0x0a,
	0x6b, 0x26, 0xff, 0xa8, 0x10, 0x5b, 0x1e, 0x43, 0x70, 0x93, 0x3b, 0x3b, 0x57, 0x53, 0xdc, 0x69,
	0xbc, 0xe1, 0x1d, 0x89, 0x4a, 0x9f, 0xca, 0x30, 0xec, 0xef, 0x9c, 0x53, 0xb9, 0x8f, 0xa1, 0xb6,
	0x63, 0x90, 0xc6, 0xd1, 0xa7, 0xb8, 0x57, 0x77, 0x8c, 0x43, 0x2a, 0xae, 0x31, 0x7a, 0x91, 0x3d,
	0xde, 0xc0, 0xe2, 0xde, 0xd8, 0x38, 0x41, 0x23, 0x1a, 0xfb, 0x58, 0x55, 0x78, 0xa7, 0xe4, 0x22,
	0xe8, 0xce, 0x28, 0x8d, 0xa6, 0xfa, 0x09, 0xa5, 0x09, 0xd4, 0xca, 0x40, 0x2e, 0xda, 0x3f, 0x24,
	0x0a, 0x6b, 0x41, 0x7f, 0x08, 0xf9, 0x6d, 0x03, 0x37, 0xf8, 0x98, 0xcc, 0x74, 0xee, 0x92, 0xf5,
	0x3f, 0xd3, 0xa0, 0xa0, 0x68, 0x89, 0xf7, 0x2a, 0xe2, 0x06, 0x7e, 0xa9, 0x1a, 0x70, 0xb9, 0x01,
	0x29, 0xdc, 0x3f, 0xe2, 0x50, 0x6a, 0xf1, 0xe9, 0xa5, 0x5a, 0x68, 0x4c, 0x6d, 0x1b, 0x11, 0xe5,
	0xfb, 0xb0, 0x38, 0x8d, 0x2c, 0x40, 0x96, 0x39, 0x4b, 0xb5, 0xe8, 0xba, 0xf4, 0x7b, 0x90, 0xe2,
	0x01, 0x19, 0x48, 0xec, 0xed, 0x94, 0xe8, 0x7c, 0x2d, 0xb7, 0xd9, 0xa9, 0x37, 0x5b, 0xcd, 0xd6,
	0xab, 0x52, 0xa2, 0x9c, 0x83, 0xd4, 0x66, 0xfb, 0xcb, 0x56, 0x29, 0xa9, 0xff, 0x67, 0x02, 0x16,
	0xa2, 0xde, 0x46, 0x5d, 0x82, 0x6b, 0x3a, 0xd2, 0x0e, 0xea, 0x10, 0x2b, 0x21, 0x0f, 0x70, 0x13,
	0xfe, 0x59, 0x5f, 0x34, 0xd4, 0xac, 0x43, 0x49, 0x9d, 0x8b, 0xa8, 0xf2, 0x87, 0x7d, 0x44, 0x7b,
	0xae, 0x3d, 0x41, 0x1b, 0x41, 0x50, 0x0f, 0xb3, 0x29, 0x7c, 0xff, 0x5a, 0x82, 0x94, 0x63, 0x0f,
	0x4d, 0x51, 0x8d, 0x3e, 0xd7, 0x1e, 0x45, 0x14, 0x99, 0x65, 0x45, 0x62, 0x8d, 0x34, 0x71, 0x2c,
	0x2c, 0xf7, 0x26, 0xc6, 0xb0, 0x92, 0x53, 0xa0, 0x77, 0xe6, 0xfe, 0xd4, 0xea, 0x4d, 0x9d, 0x21,
	0x1f, 0xb5, 0xe6, 0xb1, 0x5a, 0x2c, 0xf6, 0x8d, 0x89, 0x58, 0xbe, 0x85, 0x0e, 0x0a, 0xbc, 0x1d,
	0xd6, 0xa2, 0xa1, 0xa4, 0xb6, 0xa1, 0x48, 0x4e, 0xcf, 0x3c, 0x73, 0xad, 0xfe, 0x0e, 0x40, 0x88,
	0xec, 0xe3, 0xc8, 0x89, 0xe2, 0xf5, 0x33, 0xf9, 0xf1, 0xb9, 0x22, 0xba, 0x92, 0x38, 0x2a, 0xbc,
	0x82, 0xed, 0x73, 0xe3, 0x6d, 0x7b, 0xa3, 0xfe, 0x62, 0xab, 0xd1, 0xeb, 0x34, 0x76, 0xdb, 0x7b,
	0x9d, 0x8d, 0xc6, 0x6e, 0x49, 0xd3, 0xff, 0x22, 0x01, 0x05, 0x11, 0xa5, 0xb8, 0xc8, 0x21, 0x8b,
	0x1f, 0x79, 0xde, 0x44, 0xd6, 0x5d, 0x97, 0x6a, 0x21, 0x5c, 0xed, 0x75, 0xb7, 0xbb, 0x83, 0xba,
	0x5b, 0x18, 0x98, 0x43, 0xe3, 0xd4, 0x2f, 0x26, 0x13, 0xac, 0xd5, 0xc4, 0x27, 0xcf, 0x30, 0x36,
	0x95, 0xa8, 0xbf, 0x70, 0xd0, 0x97, 0x7d, 0x6c, 0x52, 0x62, 0x9f, 0xa0, 0x45, 0x96, 0xe2, 0x75,
	0xa8, 0x30, 0x48, 0xe2, 0xe9, 0x13, 0x9c, 0x76, 0x7e, 0x58, 0x23, 0xdb, 0x2c, 0x3c, 0xd7, 0x3e,
	0xc5, 0x04, 0x74, 0xf9, 0xd0, 0x31, 0xfa, 0x66, 0x6f, 0x62, 0x3a, 0x96, 0x3d, 0xf0, 0x59, 0x64,
	0x7c, 0xfe, 0xd7, 0x20, 0x8b, 0xcd, 0xc7, 0xc8, 0x18, 0x0f, 0xd8, 0x4e, 0xb4, 0x21, 0x36, 0xc4,
	0x6f, 0xd2, 0x4c, 0xf5, 0xff, 0x41, 0x8a, 0xe5, 0x57, 0xde, 0x4e, 0xfa, 0x5b, 0x20, 0x73, 0xb3,
	0xef, 0x26, 0x84, 0xb9, 0x1f, 0x93, 0xb9, 0xfd, 0xc6, 0x90, 0x3c, 0x78, 0x41, 0xff, 0x2e, 0x41,
	0xc1, 0xca, 0x67, 0x54, 0xfe, 0x61, 0xf8, 0x7c, 0x5b, 0x1c, 0xfa, 0x57, 0xc3, 0x33, 0x45, 0xcf,
	0xba, 0x31, 0xb3, 0xa5, 0xa6, 0x8e, 0xa5, 0x72, 0x50, 0x29, 0x42, 0xb9, 0xd7, 0x69, 0x96, 0x6f,
	0x61, 0x66, 0x1d, 0x9f, 0x58, 0x8e, 0x3d, 0xe6, 0xb8, 0xa0, 0x8a, 0xd9, 0x46, 0x00, 0xc3, 0xf0,
	0x96, 0x76, 0x8f, 0xcc, 0xe1, 0x90, 0x17, 0x9b, 0x7b, 0x9e, 0xf2, 0x9c, 0xa9, 0x19, 0xc4, 0xcc,
	0xa4, 0xda, 0x81, 0x86, 0x73, 0x38, 0x25, 0x7a, 0xd1, 0xd5, 0xe5, 0x7d, 0xc7, 0xe1, 0x50, 0x53,
	0x6d, 0x51, 0x5c, 0x6b, 0xc6, 0x42, 0x6d, 0x19, 0xa3, 0x82, 0xc8, 0xeb, 0xc6, 0xfe, 0x50, 0xb8,
	0x79, 0xae, 0xbc, 0x02, 0x59, 0xf3, 0x5b, 0x0f, 0x95, 0xed, 0xc9, 0xd4, 0xe3, 0x4f, 0xd8, 0x47,
	0xf7, 0x37, 0x79, 0xcd, 0xb9, 0xea, 0x63, 0x58, 0x88, 0x2e, 0x14, 0xf1, 0xd6, 0x48, 0x64, 0x63,
	0xe2, 0x8c, 0x39, 0xcd, 0x9e, 0x04, 0x5d, 0x52, 0x5e, 0xff, 0x69, 0x02, 0x8a, 0x91, 0xc2, 0xf0,
	0xc3, 0x6b, 0x8a, 0xdc, 0x1c, 0x47, 0x8f, 0x98, 0x3d, 0x11, 0x37, 0x7b, 0xf4, 0x36, 0xa2, 0x30,
	0xef, 0x36, 0x22, 0x5a, 0xc2, 0xa7, 0xe3, 0x0d, 0xb1, 0x0a, 0x38, 0xc2, 0xab, 0x29, 0x2d, 0x30,
	0x9c, 0x2f, 0x4a, 0xf2, 0xa1, 0xc3, 0x60, 0xba, 0x26, 0x78, 0xff, 0xed, 0x88, 0xfe, 0x53, 0x0d,
	0x20, 0x38, 0xe2, 0xe4, 0xa0, 0x3c, 0x90, 0x1a, 0x53, 0x01, 0x9a, 0xf6, 0x65, 0x39, 0x94, 0x93,
	0x16, 0x9e, 0xa7, 0x9e, 0x3d, 0x79, 0xf6, 0x44, 0x95, 0x1d, 0x29, 0x9e, 0x38, 0x1c, 0x96, 0xd8,
	0xc0, 0x33, 0xad, 0x74, 0x38, 0x65, 0x65, 0xe5, 0x6d, 0x88, 0x4c, 0x59, 0xfa, 0x5f, 0x6a, 0x90,
	0x0f, 0x8e, 0x07, 0xa2, 0xb9, 0x42, 0x6c, 0x0b, 0x31, 0x3d, 0x29, 0x3c, 0xcd, 0xd3, 0x7f, 0x12,
	0x55, 0xd3, 0xcc, 0x49, 0x05, 0x96, 0xc8, 0x86, 0xe7, 0x61, 0xc7, 0x32, 0xf5, 0x7c, 0x2d, 0x42,
	0xad, 0xae, 0x40, 0x58, 0x26, 0x25, 0xe4, 0x6d, 0x4a, 0xf4, 0x12, 0x2c, 0x1c, 0x88, 0xb3, 0xa1,
	0x40, 0xac, 0xff, 0x6b, 0x02, 0xd2, 0x6f, 0x69, 0xa7, 0x22, 0x51, 0x38, 0xe2, 0x15, 0x6a, 0x0c,
	0xf5, 0xaf, 0x4d, 0xdc, 0xbe, 0x31, 0x34, 0x1c, 0x3f, 0x23, 0x0a, 0xe4, 0x2e, 0x03, 0x09, 0xed,
	0x18, 0xe3, 0x43, 0xd3, 0x95, 0x29, 0x42, 0xa1, 0x3b, 0x0c, 0xc4, 0xa0, 0x98, 0x74, 0x4d, 0x4f,
	0xfa, 0x30, 0xa8, 0xa1, 0xa6, 0xc7, 0x33, 0xa2, 0x0b, 0xb0, 0x62, 0x0b, 0xc1, 0x8c, 0x08, 0xaa,
	0x62, 0x94, 0x96, 0xcc, 0x23, 0x9e, 0xa4, 0x55, 0x6f, 0x43, 0x9a, 0xd9, 0x12, 0x7c, 0x1f, 0xab,
	0xe8, 0x31, 0xc3, 0x53, 0x64, 0x35, 0x73, 0x2c, 0xca, 0xe1, 0x54, 0xf5, 0x2e, 0x64, 0xe4, 0xdc,
	0xeb, 0x90, 0x66, 0xd1, 0x64, 0x5c, 0x28, 0x86, 0x25, 0xab, 0x2e, 0x43, 0x92, 0xc4, 0xc0, 0xcd,
	0x85, 0x3d, 0xc5, 0x88, 0x49, 0xf2, 0xd5, 0x15, 0x0c, 0xe5, 0x28, 0x41, 0xbc, 0x58, 0xfa, 0x24,
	0xb8, 0x0c, 0xda, 0xdd, 0xa8, 0x6f, 0xd5, 0x3b, 0xa5, 0x1f, 0xd0, 0xff, 0x9d, 0x7a, 0xeb, 0x15,
	0x05, 0x78, 0xba, 0x18, 0xda, 0x6d, 0x74, 0x45, 0x8e, 0xed, 0x36, 0xbe, 0xea, 0x62, 0x8e, 0xfd,
	0x6b, 0xb4, 0x7e, 0x60, 0x99, 0xe8, 0x95, 0xa8, 0x52, 0x76, 0xe2, 0x3c, 0x65, 0x27, 0xcf, 0x57,
	0x76, 0xea, 0x1c, 0x65, 0x67, 0x3e, 0x40, 0xd9, 0xfa, 0x77, 0x49, 0xc8, 0xcd, 0x38, 0xe2, 0xaf,
	0x46, 0xce, 0xf4, 0x8c, 0x9c, 0x33, 0x95, 0x41, 0x0d, 0x0a, 0xe8, 0x10, 0x94, 0xee, 0xb8, 0x26,
	0x13, 0xc1, 0x69, 0xcd, 0x77, 0x09, 0xfa, 0x47, 0x21, 0x65, 0xbc, 0x4b, 0x61, 0x74, 0x38, 0x96,
	0xce, 0x58, 0x0e, 0x08, 0x31, 0x42, 0x88, 0x52, 0xe7, 0x11, 0xb9, 0xd8, 0x89, 0xdd, 0xe7, 0x60,
	0x9c, 0x67, 0xb2, 0x2b, 0x61, 0x7e, 0x12, 0xc5, 0xf9, 0xec, 0x0e, 0x2c, 0xc5, 0x27, 0x88, 0x14,
	0x26, 0xac, 0xa6, 0xaa, 0x8b, 0x65, 0x96, 0xe2, 0xfe, 0x29, 0x14, 0x26, 0x14, 0x20, 0x30, 0xf8,
	0x8c, 0xfb, 0xa6, 0xcc, 0xf0, 0xd7, 0x67, 0xc5, 0xa8, 0xed, 0x04, 0x54, 0x54, 0x95, 0x9c, 0xd8,
	0xc3, 0xe9, 0x48, 0x5d, 0x4c, 0x66, 0x6b, 0x6f, 0xf9, 0x67, 0x75, 0x0d, 0x0a, 0x61, 0xba, 0x50,
	0x20, 0xab, 0x2e, 0xc1, 0x42, 0x44, 0x56, 0xfd, 0xef, 0x35, 0xa8, 0x74, 0x1d, 0xe3, 0xe0, 0xc0,
	0xea, 0x53, 0xe8, 0x45, 0x35, 0x52, 0x4b, 0x84, 0x43, 0xad, 0xbe, 0x1b, 0x09, 0x81, 0x18, 0xc3,
	0xf6, 0x8d, 0xfe, 0xf1, 0xd0, 0x3e, 0xe4, 0xe9, 0x52, 0xec, 0x4c, 0xa7, 0x9e, 0x74, 0x60, 0xfe,
	0x39, 0x70, 0xec, 0x89, 0x30, 0x5d, 0x8a, 0xb2, 0x17, 0x45, 0xd6, 0xa1, 0x35, 0xb2, 0x3c, 0x51,
	0x2b, 0xa4, 0x88, 0xc5, 0x04, 0x59, 0x98, 0x9e, 0xa8, 0x0d, 0x52, 0xb4, 0x6f, 0xbe, 0x19, 0x9a,
	0x63, 0x56, 0x3b, 0xa3, 0xb1, 0x64, 0x36, 0xf7, 0x27, 0x2e, 0x1b, 0xcc, 0x07, 0x4c, 0x10, 0x90,
	0x67, 0x40, 0x49, 0xde, 0xd9, 0x4c, 0xb9, 0x68, 0x43, 0x88, 0xfe, 0xb7, 0x79, 0x28, 0x2b, 0x2d,
	0x85, 0x04, 0x8f, 0xdc, 0x1a, 0x73, 0x10, 0x10, 0x16, 0xb0, 0x31, 0x40, 0x52, 0xf9, 0x70, 0x9d,
	0x6a, 0x17, 0xe2, 0xef, 0x1d, 0x39, 0xa6, 0x81, 0xb5, 0xca, 0x0d, 0x06, 0xac, 0xc3, 0x72, 0x7f,
	0x42, 0xb7, 0xee, 0xae, 0x2c, 0x4d, 0xa9, 0x96, 0x91, 0x65, 0x14, 0x6e, 0xce, 0x15, 0x46, 0xba,
	0xa7, 0xa8, 0xd7, 0x51, 0x08, 0xcd, 0x75, 0x14, 0x2d, 0x98, 0xd1, 0xbc, 0x62, 0x51, 0x3e, 0xa1,
	0x85, 0x96, 0x18, 0x36, 0x76, 0x64, 0x6d, 0x24, 0xc2, 0xfd, 0x02, 0xba, 0xc8, 0x25, 0x85, 0x40,
	0x09, 0x6c, 0xcf, 0x1b, 0x9a, 0x22, 0x85, 0x2e, 0xe0, 0x56, 0xac, 0x30, 0xca, 0x87, 0x87, 0x66,
	0xca, 0x2b, 0xae, 0x23, 0x12, 0x80, 0x0f, 0x11, 0x85, 0x09, 0xee, 0xb0, 0x7a, 0x50, 0xc2, 0x00,
	0x81, 0xff, 0xb9, 0xef, 0x24, 0xfa, 0x2e, 0xa3, 0xe5, 0x38, 0x16, 0x50, 0x22, 0x84, 0x19, 0xb0,
	0x71, 0x25, 0x84, 0x6b, 0x1f, 0x78, 0x11, 0xec, 0x3d, 0xc6, 0xae, 0xd2, 0x93, 0x8d, 0x51, 0xef,
	0xc0, 0x1a, 0x9a, 0x12, 0x0e, 0x61, 0x38, 0x36, 0x77, 0x63, 0x09, 0x2f, 0x84, 0xa7, 0xe1, 0x82,
	0x44, 0x22, 0xee, 0x33, 0x62, 0x05, 0x16, 0x08, 0xe1, 0xb8, 0xae, 0x04, 0xa7, 0xc3, 0x52, 0x8f,
	0x8c, 0xc9, 0x84, 0x8e, 0xa6, 0x83, 0x69, 0x8a, 0xe1, 0x69, 0xdc, 0x77, 0xc6, 0x44, 0xc2, 0x1f,
	0x84, 0x87, 0x4d, 0xc7, 0xe6, 0x89, 0xd5, 0xe7, 0x1a, 0x49, 0xa2, 0x1f, 0x32, 0x1a, 0xd5, 0xc8,
	0x8b, 0xb5, 0xdf, 0xf5, 0x26, 0x94, 0x57, 0xb1, 0x64, 0xed, 0xf5, 0xed, 0x29, 0xd5, 0xc0, 0x95,
	0x9b, 0x4c, 0x71, 0x1b, 0xd6, 0x79, 0x5e, 0x73, 0x60, 0x4d, 0x47, 0xb3, 0x44, 0xb7, 0x98, 0xe8,
	0x2e, 0x5c, 0xe3, 0xc5, 0x38, 0xd8, 0x29, 0xf4, 0xe9, 0xcc, 0x36, 0x4e, 0xa6, 0x33, 0x59, 0x05,
	0x4a, 0x14, 0x3f, 0x22, 0xda, 0xab, 0x2a, 0x6d, 0x30, 0x06, 0xb7, 0xd4, 0x40, 0x22, 0xd6, 0xa5,
	0xfc, 0x29, 0xdc, 0x13, 0x07, 0xf2, 0x19, 0xc6, 0x12, 0x79, 0xf6, 0x41, 0x68, 0x07, 0xe3, 0xb2,
	0xc7, 0xa6, 0xd7, 0x73, 0xbe, 0xed, 0x29, 0x97, 0x59, 0xe4, 0x61, 0x97, 0xa1, 0x28, 0xe1, 0x82,
	0xd9, 0x92, 0x52, 0xad, 0x84, 0x9a, 0x74, 0x25, 0xe2, 0x56, 0x4a, 0x4a, 0x77, 0x12, 0x4c, 0xae,
	0x89, 0xea, 0xad, 0x5c, 0x0a, 0xc3, 0xbd, 0x80, 0x79, 0x39, 0xcc, 0xdc, 0x53, 0xcc, 0x97, 0xc3,
	0xcc, 0x3d, 0x9f, 0xf9, 0xe5, 0x18, 0x13, 0xc5, 0x7c, 0x85, 0xe1, 0xb7, 0x60, 0x8d, 0xe1, 0xfd,
	0x49, 0xcf, 0xf1, 0xbc, 0xde, 0xc8, 0xea, 0x3b, 0xd4, 0xfe, 0xbb, 0xbd, 0xc9, 0xb3, 0x27, 0x95,
	0x55, 0xde, 0xc1, 0x67, 0x93, 0x7c, 0xf1, 0xa4, 0x72, 0xe5, 0x7d, 0x24, 0xcf, 0x2a, 0x95, 0xf7,
	0x91, 0x7c, 0x51, 0x59, 0x63, 0x12, 0x1d, 0xaa, 0x8a, 0x84, 0xaf, 0x9a, 0xc9, 0x6e, 0xea, 0x20,
	0xde, 0xad, 0x5c, 0x65, 0x1a, 0x34, 0xb1, 0xa2, 0x61, 0x4f, 0x7b, 0x67, 0xa0, 0x09, 0xc3, 0x64,
	0xd7, 0x98, 0xac, 0x0e, 0xd7, 0x99, 0x4c, 0xc4, 0x4a, 0x22, 0xa0, 0x60, 0xc9, 0x8f, 0x4e, 0x84,
	0xc9, 0x2a, 0xb7, 0x65, 0x1b, 0x79, 0x56, 0x38, 0xd5, 0x7f, 0xa9, 0x51, 0xf4, 0x15, 0xc1, 0x6a,
	0x4f, 0x5e, 0x43, 0xe4, 0x55, 0x9d, 0xad, 0xda, 0x90, 0x20, 0xab, 0x30, 0x89, 0x5f, 0x73, 0xf3,
	0x09, 0x1d, 0x79, 0xf6, 0xcc, 0x59, 0x73, 0xf5, 0x17, 0x1a, 0xe4, 0x7c, 0xb2, 0x99, 0x93, 0x5f,
	0x6d, 0xde, 0xc9, 0x2f, 0x56, 0x8c, 0xc6, 0x70, 0x88, 0x79, 0x80, 0x2e, 0x13, 0xe2, 0x0c, 0xcb,
	0xf7, 0x01, 0x42, 0xeb, 0x12, 0xa9, 0x7a, 0xb9, 0x36, 0x27, 0xce, 0x62, 0x17, 0xe0, 0x97, 0xf0,
	0x3d, 0x79, 0x5d, 0x28, 0xca, 0x7c, 0xff, 0x04, 0x49, 0xff, 0x3b, 0x80, 0xc5, 0xd8, 0xe6, 0x9e,
	0x13, 0x9e, 0x4b, 0x91, 0x23, 0x14, 0x82, 0x60, 0x3d, 0xdf, 0x3f, 0xed, 0x0f, 0xfd, 0x04, 0x73,
	0x03, 0xae, 0xe0, 0x80, 0x21, 0x45, 0x44, 0x01, 0xef, 0x1d, 0x60, 0x17, 0xe6, 0x51, 0x05, 0x27,
	0x52, 0xce, 0x75, 0x58, 0x8d, 0x11, 0x50, 0xc2, 0x22, 0x7c, 0x5a, 0xed, 0x6e, 0x6b, 0xec, 0x62,
	0xc3, 0x24, 0xed, 0x9a, 0x51, 0xae, 0x2b, 0x42, 0x95, 0x63, 0x1e, 0x98, 0x0e, 0x25, 0x4c, 0x57,
	0xe6, 0xa3, 0xcb, 0x74, 0x4c, 0x40, 0x98, 0x91, 0xe5, 0x8a, 0x17, 0x5d, 0x32, 0x07, 0xed, 0x63,
	0x91, 0x82, 0x70, 0x95, 0x95, 0xd0, 0x3f, 0x04, 0x44, 0x11, 0x82, 0xca, 0x80, 0xfb, 0x18, 0xc7,
	0xe5, 0x1a, 0x0a, 0x0a, 0x86, 0xd3, 0x28, 0x98, 0x08, 0x70, 0x74, 0xaf, 0x33, 0x99, 0xf6, 0xfa,
	0x68, 0x8d, 0x63, 0x8e, 0x06, 0x9c, 0x4b, 0xf8, 0x38, 0x52, 0xc0, 0x16, 0x19, 0xb6, 0x8c, 0x25,
	0x02, 0xee, 0x07, 0xec, 0xbf, 0xa7, 0x43, 0x4f, 0xf9, 0x3d, 0x8a, 0x38, 0xb2, 0xc6, 0x68, 0x69,
	0x09, 0x2d, 0xf9, 0x50, 0xe3, 0xf7, 0x03, 0xe8, 0x25, 0x7f, 0xa1, 0xa4, 0xaf, 0x6f, 0xb1, 0xc9,
	0x7f, 0x67, 0x79, 0xbc, 0x80, 0xb2, 0xf2, 0x64, 0x92, 0x60, 0x64, 0x1d, 0x3a, 0xf2, 0xf2, 0x6c,
	0x59, 0x8d, 0x30, 0x86, 0xd6, 0x21, 0x77, 0xba, 0x8a, 0xd7, 0x65, 0x85, 0x31, 0x47, 0xd3, 0x21,
	0x53, 0x2b, 0xcc, 0x8a, 0x8a, 0x77, 0xc3, 0x4f, 0x7a, 0x03, 0xa1, 0xb8, 0xa1, 0x4d, 0xb9, 0x75,
	0x55, 0xc5, 0xeb, 0x28, 0x42, 0x69, 0xeb, 0x8a, 0xe2, 0x18, 0xa0, 0x5d, 0xdc, 0xa6, 0x88, 0xa9,
	0x28, 0xb3, 0xc6, 0x30, 0x6a, 0xe4, 0x9a, 0xca, 0x5e, 0x01, 0x7e, 0x42, 0x56, 0x14, 0x6b, 0xab,
	0xaa, 0x68, 0x34, 0x8b, 0x55, 0x0c, 0xd6, 0x43, 0x22, 0x5b, 0x61, 0x91, 0xaf, 0x86, 0x44, 0xb6,
	0x66, 0x45, 0xbe, 0x16, 0x9a, 0xd8, 0x9a, 0x99, 0xf8, 0x7a, 0x68, 0x62, 0x6b, 0xfe, 0xc4, 0x37,
	0x94, 0xe5, 0x87, 0xc3, 0xbe, 0x9c, 0xf2, 0xa6, 0x2f, 0x8b, 0x04, 0x29, 0xda, 0x5b, 0x6a, 0xe7,
	0x10, 0x42, 0x6a, 0xc6, 0xcf, 0x3a, 0x3e, 0x4c, 0x51, 0xdf, 0x56, 0x16, 0x25, 0x4c, 0x48, 0x28,
	0x51, 0x21, 0x60, 0x81, 0x13, 0x86, 0xab, 0x41, 0x77, 0xd5, 0x14, 0x03, 0x6f, 0xb8, 0x2f, 0xe5,
	0xb9, 0xe7, 0x27, 0x36, 0x05, 0x53, 0xd4, 0x22, 0x9b, 0xe3, 0x7e, 0x64, 0x8c, 0x94, 0x48, 0x24,
	0x65, 0xac, 0x6b, 0x02, 0xa0, 0xa2, 0x7f, 0xe8, 0x27, 0x42, 0x42, 0x85, 0x64, 0x7a, 0xa4, 0xd4,
	0x18, 0x41, 0xa8, 0x61, 0x1f, 0x29, 0xa1, 0xac, 0x40, 0xa8, 0x8f, 0x95, 0x50, 0x56, 0x5c, 0xa8,
	0x1f, 0xaa, 0x9d, 0x2f, 0x5d, 0x51, 0xd0, 0xd7, 0x18, 0x5a, 0x85, 0x72, 0x08, 0xaa, 0x46, 0x3c,
	0x56, 0xfc, 0xc7, 0xf6, 0x40, 0xd9, 0xfd, 0x89, 0xe2, 0xef, 0xc3, 0x14, 0xf5, 0x27, 0x6a, 0xd1,
	0x8c, 0x91, 0x8b, 0x7e, 0xaa, 0x16, 0x1d, 0x00, 0x15, 0xfd, 0xa7, 0x6a, 0xd1, 0x8c, 0x0a, 0x2d,
	0xfa, 0x33, 0xb5, 0xe8, 0x08, 0x42, 0x0d, 0x7b, 0xc6, 0x55, 0xed, 0x06, 0x64, 0xd5, 0xcb, 0xc0,
	0xe8, 0xbd, 0x50, 0xb4, 0x45, 0x8f, 0xb4, 0xfd, 0x33, 0x37, 0x90, 0x7f, 0x93, 0x81, 0xb4, 0x78,
	0x9d, 0x74, 0x39, 0x74, 0x84, 0xec, 0x3f, 0xdb, 0xb9, 0xd0, 0xad, 0x50, 0xf4, 0xd9, 0x66, 0xf4,
	0x8e, 0x2c, 0x7c, 0x34, 0x91, 0xe2, 0x16, 0xe1, 0x12, 0x24, 0xe9, 0x90, 0x55, 0x74, 0x5b, 0xa9,
	0x1a, 0x9d, 0xd5, 0x9f, 0x7f, 0x80, 0x13, 0x3d, 0x99, 0xc8, 0xce, 0x9c, 0x4c, 0xdc, 0x82, 0x62,
	0xe8, 0x18, 0x4a, 0x3d, 0x5a, 0x8a, 0x9c, 0x43, 0xcd, 0x9e, 0x72, 0xe7, 0xe7, 0x9e, 0x72, 0x57,
	0xff, 0x3c, 0x05, 0xf9, 0x36, 0x56, 0x5c, 0x1c, 0xb3, 0xb0, 0xf8, 0x0b, 0x1f, 0x5c, 0xac, 0x08,
	0xa5, 0xd4, 0x7c, 0xbc, 0xe8, 0x56, 0xef, 0xd3, 0xb1, 0x2f, 0xbd, 0xcf, 0x92, 0x0d, 0xd6, 0x95,
	0x19, 0x32, 0xf1, 0x7c, 0xab, 0xfc, 0x10, 0x1b, 0x15, 0x6e, 0xf8, 0x4c, 0x99, 0x2c, 0x2b, 0x33,
	0x94, 0xa2, 0x21, 0x34, 0xe9, 0x88, 0x72, 0x3a, 0x56, 0xc4, 0xea, 0x88, 0x32, 0x4e, 0xbc, 0xa7,
	0x28, 0x48, 0x84, 0x3e, 0x76, 0x28, 0x9e, 0x29, 0xbb, 0xde, 0x59, 0x11, 0x36, 0x18, 0x4d, 0x22,
	0x0c, 0x70, 0xbf, 0x38, 0xf6, 0xa9, 0xec, 0xe3, 0x67, 0x45, 0xd8, 0x14, 0xf8, 0x2a, 0xf2, 0x94,
	0x72, 0x5f, 0x93, 0x79, 0x46, 0xbc, 0x26, 0xd1, 0x62, 0x37, 0x7f, 0x48, 0x98, 0x55, 0x62, 0x9f,
	0x7b, 0x97, 0x5e, 0x7d, 0x08, 0xf9, 0x40, 0xe4, 0xf3, 0x49, 0xef, 0x40, 0x46, 0x4a, 0x5c, 0x85,
	0xac, 0x68, 0x5f, 0xe7, 0x50, 0xdd, 0x85, 0xac, 0x94, 0xf6, 0x3c, 0x32, 0xfd, 0x55, 0x70, 0xc0,
	0xb2, 0x55, 0xdf, 0x6b, 0x6d, 0xbc, 0x2e, 0x69, 0xe5, 0x02, 0x0a, 0xdd, 0xd8, 0x6d, 0x74, 0xde,
	0x36, 0x4a, 0x09, 0x6c, 0x4a, 0xf3, 0x7b, 0x2d, 0xf5, 0x33, 0x49, 0x74, 0x1b, 0x9d, 0x06, 0xbd,
	0xca, 0xa5, 0xc3, 0x9f, 0xec, 0x66, 0x63, 0xb7, 0xdb, 0x69, 0x7f, 0x5d, 0x4a, 0xeb, 0xff, 0xa8,
	0x41, 0x31, 0xfc, 0x36, 0xef, 0x0c, 0x97, 0x91, 0x1b, 0x3c, 0x11, 0xda, 0xe0, 0x17, 0xb9, 0x42,
	0x0f, 0x7b, 0x51, 0x2a, 0xe6, 0xc3, 0xb3, 0xfb, 0x57, 0x5c, 0x9e, 0xc7, 0xf7, 0x6f, 0x54, 0xad,
	0x99, 0xb8, 0x26, 0xfe, 0x21, 0x01, 0x39, 0xff, 0xc6, 0xf6, 0xa2, 0x2f, 0xe9, 0xcf, 0xf3, 0xee,
	0xc8, 0x74, 0xa9, 0xb8, 0xe3, 0xde, 0x80, 0x9c, 0x72, 0x4c, 0xb9, 0x31, 0x63, 0xf5, 0xe5, 0xf9,
	0x27, 0xfe, 0xd1, 0xa3, 0xdf, 0xfc, 0xdc, 0xa3, 0x5f, 0x75, 0x7c, 0x2b, 0x5e, 0x79, 0xa3, 0x9a,
	0xc5, 0x35, 0x6c, 0x8f, 0x0f, 0x25, 0xfd, 0xe3, 0xe6, 0xf0, 0xfd, 0x48, 0x70, 0x4b, 0x03, 0xe7,
	0xbc, 0x8c, 0x2f, 0xcc, 0x3d, 0xfb, 0xfd, 0x2e, 0x0f, 0x10, 0x7a, 0x75, 0x7e, 0xf6, 0x7d, 0xb0,
	0xff, 0x6d, 0x40, 0x62, 0xe6, 0xdb, 0x80, 0xd0, 0xad, 0xb7, 0x38, 0x08, 0xd6, 0xfd, 0x13, 0x69,
	0xf1, 0xc4, 0xbf, 0x1c, 0x7a, 0xc7, 0x56, 0xdb, 0x15, 0x9a, 0x44, 0x1a, 0x74, 0x07, 0x17, 0xab,
	0x5e, 0x98, 0xa5, 0xe9, 0x30, 0xc6, 0x57, 0x05, 0x3f, 0x31, 0x8f, 0x3d, 0xb4, 0x88, 0xee, 0xa6,
	0xd8, 0xb9, 0x7d, 0x76, 0xf6, 0x85, 0x4e, 0xa4, 0xf4, 0xe6, 0x1b, 0x1a, 0xff, 0xad, 0x5f, 0x81,
	0xd9, 0x87, 0x2e, 0xbc, 0x73, 0x7c, 0xe7, 0x10, 0xa8, 0xb5, 0x18, 0x55, 0xeb, 0x23, 0x51, 0x50,
	0x8a, 0xe2, 0x5f, 0x3e, 0x74, 0x10, 0xdd, 0x6c, 0x29, 0xb0, 0xa5, 0x7c, 0xb5, 0xf7, 0x02, 0x32,
	0x72, 0xc1, 0x97, 0x60, 0x41, 0x5c, 0x71, 0xf5, 0xb6, 0xeb, 0xbb, 0xdd, 0x06, 0x9d, 0x89, 0x96,
	0xa0, 0x28, 0x41, 0xbb, 0x5b, 0x75, 0x74, 0x54, 0x2a, 0x76, 0x97, 0x24, 0xa4, 0xf1, 0x55, 0x63,
	0x63, 0xaf, 0xdb, 0xee, 0x94, 0x12, 0xfa, 0x5f, 0x65, 0x20, 0x23, 0x35, 0xa2, 0xc3, 0x75, 0xf4,
	0xe3, 0xdd, 0x76, 0xab, 0xb7, 0xd1, 0xde, 0xde, 0xae, 0xb7, 0x36, 0x7d, 0xba, 0xde, 0xcb, 0x7a,
	0x73, 0xab, 0xb1, 0x89, 0x5c, 0xc3, 0x34, 0xad, 0x6e, 0xbd, 0xd9, 0x6a, 0x74, 0x7a, 0x22, 0x4a,
	0x28, 0x9a, 0x15, 0xdc, 0xc7, 0xeb, 0xb3, 0x34, 0xcd, 0xed, 0x66, 0xb7, 0xde, 0x6d, 0xb6, 0x5b,
	0xa5, 0x65, 0xec, 0xa6, 0x6e, 0x9e, 0x43, 0xd0, 0xdb, 0x6c, 0xee, 0xbe, 0x29, 0x5d, 0x2e, 0xdf,
	0x03, 0xfd, 0x3c, 0xaa, 0xed, 0xc6, 0x76, 0xbb, 0xf3, 0x75, 0x29, 0x87, 0xf9, 0xae, 0x3a, 0x43,
	0xb7, 0xd3, 0x69, 0x34, 0xb6, 0x77, 0xba, 0x28, 0xce, 0xa5, 0xb9, 0x22, 0x8b, 0xcf, 0x08, 0x94,
	0xc8, 0xab, 0xe5, 0x07, 0x70, 0x47, 0xd2, 0xf8, 0x4b, 0xee, 0x34, 0x5e, 0x35, 0x31, 0x92, 0x89,
	0xc9, 0xba, 0xcd, 0xed, 0x46, 0x7b, 0xaf, 0x5b, 0xba, 0x82, 0xf6, 0xb9, 0x37, 0x4b, 0x39, 0x97,
	0xb6, 0x12, 0x92, 0xcc, 0xa7, 0x45, 0xdb, 0x6c, 0x37, 0x5b, 0x75, 0x92, 0x4c, 0xc3, 0x8d, 0x75,
	0x35, 0x8e, 0xa7, 0xc0, 0x4a, 0xbc, 0x90, 0xe5, 0x26, 0x86, 0xda, 0xab, 0x50, 0x91, 0x14, 0x2f,
	0x3b, 0xf5, 0xed, 0xc6, 0x97, 0xed, 0xce, 0x1b, 0x9c, 0x6e, 0xbb, 0xfd, 0x16, 0xb1, 0x49, 0x32,
	0xa8, 0xc4, 0xbe, 0xda, 0xe8, 0x35, 0x3a, 0x1d, 0x34, 0x68, 0x2a, 0x34, 0x69, 0xb3, 0xf5, 0xb6,
	0xbe, 0xd5, 0xdc, 0x0c, 0x86, 0x36, 0x37, 0x4b, 0x69, 0xf4, 0xb5, 0x95, 0x18, 0xbe, 0xfd, 0xf2,
	0x65, 0xa3, 0xb3, 0x5b, 0xca, 0x84, 0x86, 0x8a, 0x5d, 0x44, 0x96, 0x40, 0x9d, 0xb5, 0x1a, 0x1b,
	0x24, 0x6f, 0x36, 0x34, 0xb4, 0xd3, 0x40, 0xf8, 0x46, 0x73, 0xab, 0x29, 0x4c, 0x9a, 0x0f, 0x09,
	0xea, 0x5f, 0xb6, 0xe2, 0x5a, 0xde, 0xb4, 0xe8, 0x92, 0xbb, 0x8c, 0x81, 0x6b, 0x4d, 0x62, 0x79,
	0x2f, 0x46, 0xf9, 0x02, 0x06, 0x86, 0xcb, 0x11, 0xb4, 0x5a, 0x61, 0x01, 0xdd, 0x72, 0x35, 0x86,
	0xd9, 0xed, 0xd6, 0x3b, 0x34, 0xaa, 0x38, 0x33, 0x4a, 0x4d, 0xb7, 0x20, 0x2e, 0x7f, 0x19, 0xd3,
	0xad, 0xef, 0xbe, 0x51, 0xeb, 0x2c, 0x2d, 0x86, 0xa4, 0x64, 0xc4, 0x5e, 0xab, 0xbe, 0xd7, 0x7d,
	0xdd, 0xee, 0x34, 0x7f, 0x8c, 0x0c, 0x97, 0xe2, 0xc3, 0x14, 0xbf, 0x92, 0x7e, 0x07, 0xb2, 0xea,
	0xb9, 0xf7, 0x1a, 0x2c, 0x62, 0x71, 0x39, 0x75, 0xcd, 0xe8, 0xdb, 0xc2, 0xe7, 0xda, 0x33, 0xfd,
	0x27, 0x50, 0x08, 0x5f, 0x62, 0x3e, 0x80, 0xfc, 0x89, 0xe1, 0x58, 0x74, 0x86, 0xa6, 0x92, 0xec,
	0x4a, 0xf8, 0x96, 0xb3, 0xf6, 0x56, 0x62, 0xb1, 0x22, 0xc8, 0xa9, 0xff, 0x63, 0x59, 0xc6, 0xbf,
	0xfa, 0x48, 0xc8, 0x4f, 0x58, 0xf2, 0xc1, 0xe3, 0x8a, 0x02, 0x24, 0x8f, 0xcd, 0xd3, 0xf9, 0x84,
	0x1f, 0x01, 0xf8, 0x84, 0x2e, 0x6a, 0x3f, 0x3f, 0x51, 0xbf, 0xa4, 0x24, 0xa1, 0x57, 0x1a, 0xfa,
	0x63, 0x00, 0x2c, 0x1e, 0x06, 0x28, 0x92, 0x65, 0x0c, 0xe7, 0x9c, 0xa9, 0xf3, 0x1d, 0xa0, 0x89,
	0x05, 0x93, 0x27, 0x1f, 0x53, 0x3c, 0x86, 0x42, 0x30, 0xc0, 0xa5, 0xf0, 0xd8, 0x0f, 0x7e, 0xca,
	0x09, 0x0a, 0xb5, 0x80, 0x44, 0xff, 0x11, 0xe4, 0x3b, 0x18, 0xcb, 0xb7, 0xe8, 0x1c, 0x8f, 0xe4,
	0xfe, 0x66, 0x22, 0xd5, 0x16, 0x9d, 0x4d, 0x3c, 0x71, 0xc0, 0x0a, 0x98, 0xde, 0x11, 0xf4, 0xd5,
	0xdb, 0x8a, 0x94, 0x7e, 0x0c, 0xe0, 0x0f, 0x77, 0x71, 0x4b, 0x64, 0xe4, 0xf9, 0xb7, 0x5a, 0x4a,
	0xc0, 0x1b, 0x7b, 0x4b, 0xe3, 0xf0, 0xd0, 0x31, 0x0f, 0xe9, 0xf3, 0xae, 0x81, 0xc9, 0x3d, 0x74,
	0x8f, 0x66, 0x4b, 0xa8, 0x83, 0xab, 0x59, 0x74, 0x6c, 0xb2, 0x7f, 0xd6, 0x20, 0xdd, 0x1c, 0x89,
	0xf7, 0xc5, 0xd1, 0x6b, 0x38, 0x86, 0x8a, 0x1a, 0x16, 0x51, 0xc6, 0x64, 0xd2, 0xf7, 0xbf, 0xc9,
	0x12, 0xa8, 0x3a, 0x82, 0xe8, 0xb6, 0x65, 0x60, 0xf7, 0x8f, 0xcd, 0xe0, 0x32, 0x46, 0x20, 0x37,
	0x19, 0x58, 0xfd, 0x02, 0x52, 0x4c, 0x16, 0xb5, 0xb3, 0xb8, 0x12, 0x10, 0xaf, 0x73, 0x82, 0xcc,
	0x90, 0x8c, 0x3e, 0x8b, 0x58, 0x85, 0x8c, 0x60, 0x12, 0xfb, 0xb0, 0xe9, 0xaa, 0xac, 0xd7, 0x72,
	0xc8, 0x7a, 0x67, 0x67, 0x03, 0xe3, 0x0a, 0x56, 0x64, 0x9b, 0xed, 0x8d, 0x37, 0x0d, 0x8a, 0xef,
	0x7f, 0x00, 0x19, 0x71, 0x81, 0x81, 0x8a, 0x13, 0x6f, 0x5b, 0x92, 0xbc, 0x9e, 0xa2, 0xbc, 0xd7,
	0x10, 0xcf, 0x5a, 0xe8, 0xb0, 0xc2, 0xcf, 0x3a, 0xfc, 0x40, 0x40, 0x93, 0xcd, 0x47, 0x9e, 0xda,
	0x91, 0x5e, 0xf0, 0x66, 0xa0, 0xbc, 0xa2, 0xae, 0xbd, 0x45, 0xd1, 0x95, 0x11, 0xeb, 0xd3, 0x57,
	0x83, 0xf7, 0x2e, 0x9d, 0x2f, 0x51, 0x06, 0xfa, 0xdb, 0xc6, 0xf9, 0x7f, 0x9e, 0x80, 0x42, 0xcb,
	0xf4, 0xfc, 0xd7, 0x2d, 0x1f, 0x43, 0xd1, 0x9a, 0xf4, 0xe4, 0x3d, 0xad, 0xdf, 0xbe, 0xac, 0xd6,
	0x42, 0x34, 0xb5, 0xe6, 0x8e, 0x7a, 0x6a, 0xf4, 0x11, 0xe4, 0xf8, 0x83, 0xc6, 0xbe, 0x3d, 0xe4,
	0x1d, 0x43, 0x5d, 0x45, 0x98, 0x72, 0x47, 0x22, 0xf9, 0xe3, 0x85, 0x55, 0xec, 0x6a, 0x7d, 0xd6,
	0x42, 0x5a, 0x86, 0xe3, 0xfe, 0x3d, 0x74, 0xec, 0xe9, 0x44, 0xdc, 0xe2, 0x86, 0x35, 0x9c, 0x8a,
	0x6a, 0xf8, 0x35, 0xe4, 0x83, 0xa9, 0xef, 0x5f, 0x70, 0x6a, 0x6e, 0xa6, 0x63, 0xd3, 0xea, 0xd7,
	0x21, 0xe7, 0xe3, 0xd1, 0x2e, 0xcd, 0x9d, 0x93, 0xcf, 0x50, 0x27, 0xe2, 0xbf, 0xcf, 0x51, 0x2b,
	0xff, 0x95, 0x8a, 0xbf, 0x26, 0xb8, 0x15, 0xd9, 0x6d, 0xcb, 0xd1, 0xba, 0x4d, 0xec, 0xba, 0x4a,
	0x50, 0xb4, 0x8b, 0xbe, 0x54, 0xdd, 0x4d, 0xc5, 0xba, 0x46, 0xb2, 0xd2, 0xc3, 0xd8, 0x36, 0x5c,
	0x8b, 0x31, 0x14, 0x3b, 0x89, 0x67, 0xbe, 0x0f, 0x69, 0x64, 0x69, 0xbb, 0xb2, 0xee, 0xa9, 0xc4,
	0x28, 0xb7, 0x09, 0xc7, 0x84, 0xb7, 0xf9, 0xc8, 0xda, 0x7f, 0x2c, 0xa8, 0x7a, 0xcb, 0x62, 0x58,
	0x2d, 0xd5, 0x7f, 0x4f, 0x00, 0x84, 0x98, 0xc7, 0x1e, 0x49, 0xfc, 0x7f, 0xc8, 0x4a, 0x16, 0xf2,
	0x89, 0xd5, 0xad, 0x33, 0xe5, 0x52, 0x5c, 0x9f, 0xa7, 0x5e, 0xb7, 0x77, 0xbb, 0xe5, 0x5f, 0x87,
	0x05, 0xba, 0xa1, 0xe7, 0x1b, 0x0d, 0x6b, 0x7c, 0xa8, 0x6e, 0xe4, 0xef, 0x9e, 0x3d, 0x7e, 0x07,
	0xc9, 0xb7, 0x05, 0x35, 0xdd, 0xbb, 0x63, 0x9c, 0x39, 0xb1, 0x86, 0xe6, 0xa1, 0x29, 0xda, 0x05,
	0xff, 0x01, 0x14, 0xb6, 0xcb, 0x7e, 0x74, 0x0c, 0x2e, 0xf2, 0x83, 0x38, 0x5b, 0x81, 0xd2, 0x81,
	0xed, 0xd0, 0x43, 0x9c, 0xe9, 0x70, 0xd8, 0x13, 0x8b, 0xe1, 0x77, 0x29, 0xd5, 0xdf, 0x82, 0x42,
	0x78, 0x0e, 0xdf, 0x57, 0x82, 0xd7, 0x36, 0x51, 0xb7, 0x22, 0xb8, 0x78, 0xed, 0x50, 0x0a, 0xed,
	0x2d, 0xf1, 0xbd, 0x0c, 0x76, 0x9a, 0x72, 0xbd, 0xb4, 0x4b, 0x68, 0xc5, 0xc2, 0x8f, 0x5f, 0x74,
	0x9a, 0x9b, 0xaf, 0x1a, 0xe2, 0x36, 0xbb, 0xd5, 0x6e, 0x61, 0xbf, 0x55, 0xd5, 0x21, 0x1f, 0xd8,
	0x64, 0x25, 0xd0, 0x6f, 0xd8, 0x1b, 0xaf, 0x05, 0x3d, 0x9c, 0x8c, 0x04, 0x5a, 0x39, 0x0f, 0xe9,
	0x6d, 0xcc, 0xcd, 0xbb, 0xb8, 0xfd, 0x3e, 0x87, 0xa5, 0x58, 0x2d, 0x39, 0x6b, 0x5c, 0x6d, 0xd6,
	0xb8, 0xfa, 0x4d, 0x6a, 0x72, 0xb9, 0x4c, 0x5d, 0xf5, 0x7d, 0x48, 0x7d, 0xb3, 0xc5, 0x08, 0xfd,
	0x36, 0xa4, 0xf9, 0x9f, 0x33, 0xd3, 0x13, 0x2d, 0xd6, 0x84, 0x14, 0x29, 0x8e, 0x1c, 0x73, 0x3c,
	0x1d, 0xed, 0xcb, 0xb7, 0x6e, 0x0b, 0xa1, 0xb7, 0x6e, 0xf2, 0xc5, 0x47, 0x54, 0x49, 0xd8, 0xe6,
	0xc3, 0x89, 0xe5, 0x5a, 0xb2, 0xa5, 0x4b, 0xf1, 0x06, 0x5a, 0x8b, 0xf6, 0x1c, 0xb5, 0xb7, 0x3e,
	0x01, 0x2a, 0x21, 0x4d, 0xd3, 0xb8, 0xf4, 0x64, 0x95, 0x94, 0xaf, 0x64, 0x4d, 0xf3, 0xd6, 0xd0,
	0xff, 0x43, 0x83, 0x85, 0xe8, 0x97, 0xbc, 0x51, 0xfe, 0xc2, 0x13, 0xcf, 0xe6, 0x1f, 0x13, 0x77,
	0x39, 0xfa, 0xae, 0x29, 0xa9, 0xd6, 0xc0, 0xf7, 0x01, 0x74, 0x00, 0x9f, 0x8a, 0xbf, 0x5a, 0x49,
	0xab, 0x78, 0x2a, 0x84, 0xcb, 0x48, 0x0b, 0x0a, 0x99, 0x83, 0x20, 0x95, 0x8d, 0x04, 0x29, 0xb4,
	0x1d, 0x84, 0x64, 0xc0, 0x5e, 0xdc, 0x2f, 0xef, 0xb0, 0x3c, 0xc7, 0xfe, 0x7b, 0x63, 0x6b, 0x8f,
	0x3b, 0x00, 0x7e, 0x72, 0xd8, 0xf8, 0x0a, 0xff, 0x6d, 0xd5, 0xb7, 0xd0, 0xe6, 0xbf, 0xd4, 0xe0,
	0x12, 0xa5, 0x1e, 0xde, 0x20, 0xdb, 0xc6, 0xd8, 0x3a, 0xa0, 0x93, 0x30, 0x34, 0x81, 0xd1, 0x7f,
	0x63, 0x8d, 0x07, 0x41, 0xc0, 0x37, 0xfa, 0x6f, 0xfd, 0x4f, 0x70, 0xc2, 0x2f, 0x10, 0x93, 0xfc,
	0xeb, 0x41, 0x28, 0x78, 0x26, 0x39, 0x5c, 0xcc, 0x30, 0x15, 0x92, 0x96, 0x9f, 0x42, 0xc1, 0x18,
	0x8f, 0x6d, 0x4f, 0x9e, 0x7e, 0x0b, 0xcf, 0xba, 0x36, 0x87, 0xbc, 0xee, 0x53, 0x55, 0xef, 0xa8,
	0xed, 0x73, 0x5e, 0x1d, 0x54, 0x7d, 0x08, 0x10, 0x8c, 0x39, 0x97, 0xf4, 0xd1, 0xef, 0x62, 0x8b,
	0x24, 0x36, 0xf8, 0x2a, 0x94, 0x37, 0x3b, 0xcd, 0xb7, 0x58, 0xd5, 0xb6, 0xda, 0xdd, 0x9e, 0x2a,
	0x23, 0xe9, 0x5a, 0x60, 0x51, 0xc2, 0x3b, 0x7b, 0x2d, 0xf9, 0x3c, 0x33, 0x80, 0xd5, 0x5f, 0xb4,
	0x99, 0x2e, 0x19, 0x82, 0xed, 0x76, 0xdb, 0x3b, 0x3b, 0x08, 0x4b, 0x3d, 0xfa, 0x53, 0x0d, 0xf2,
	0x41, 0xab, 0x8a, 0x1d, 0x17, 0x17, 0x8e, 0xc8, 0xfb, 0x15, 0xf1, 0xc9, 0x50, 0x5b, 0xa6, 0x20,
	0x9d, 0x2e, 0x81, 0x7e, 0xe0, 0x13, 0xa9, 0xc9, 0x34, 0x9f, 0xe8, 0x65, 0xb3, 0xd5, 0xdc, 0x7d,
	0xcd, 0x65, 0xff, 0x12, 0x14, 0x04, 0x48, 0xf4, 0x27, 0x49, 0x1f, 0xf0, 0xa6, 0xb9, 0x45, 0x00,
	0x7a, 0x18, 0x90, 0x67, 0xc0, 0x16, 0x45, 0x8a, 0x34, 0x9a, 0x11, 0xf8, 0xa7, 0x68, 0x02, 0xb2,
	0x2f, 0xaa, 0x50, 0xb2, 0x9d, 0xc3, 0x1a, 0x95, 0x36, 0x47, 0x66, 0x8d, 0xc3, 0xfb, 0x8b, 0x0c,
	0x67, 0x24, 0xf7, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x43, 0x0e, 0x20, 0x94, 0x2c, 0x40, 0x00,
	0x00,
}
